<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>
<!--|Using lwarp|Logic.html|-->


<div class="bodywithoutsidetoc">


<main class="bodycontainer">


<section class="textbody">

<a id="Logic-autofile-0"></a>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<a id="Logic-autopage-1"></a>
<div class="titlepage">

<h1>Mathematical Logic</h1>


<div class="author">


<div class="oneauthor">

<p>
Lorna Gregory
</p>
</div>

</div>


<div class="titledate">

<p>
August 14, 2025
</p>
</div>

</div>
<!--
...... section Contents ......
-->
<h4 id="autosec-3">Contents</h4>
<a id="Logic-autopage-3"></a>



<nav class="toc">

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>
</nav>

</section>

</main>

</div>

</body>
</html>
<!--|Start file|Introduction.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Introduction</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-4"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Introduction ......
-->
<h4 id="autosec-5"><span class="sectionnumber">1&#x2003;</span>Introduction</h4>
<a id="Logic-autopage-5"></a>
<a id="Logic-autofile-1"></a>

<p>
These are the notes from last time I taught the course. I will modify them during the course. I will mark in the margin where I plan to get to in each lecture and update this to where we have got to after each lecture (the margin comments in gray are from last
time this course was taught). I recommend you keep an eye on the “Conventions” section. I’ve left blank pages so that the page numbers in the body of the notes don’t need to change if the material at the start is modified.
</p>
<!--
...... subsection What is Logic? What is Mathematical Logic? What is this course about?                              ......
-->
<h5 id="autosec-6">What is Logic? What is Mathematical Logic? What is this course about?</h5>
<a id="Logic-autopage-6"></a>


<p>
Mathematical Logic is a branch of pure mathematics. The best description I have come across of Mathematical Logic is that Mathematical Logic takes seriously as mathematical objects things other mathematicians deal with informally. For instance, in this
course, we will consider “statements about mathematical objects” as mathematical objects in their own right and we will prove theorems about them. As a discipline Mathematical Logic includes Computability Theory, Proof Theory, Model Theory, Set Theory
and some branches of Category Theory (amongst other subjects). Logic also has a presence in and connections to Computer Science, Linguistics and Philosophy.
</p>

<p>
In this course we will be studying propositional logic, predicate logic and make some first steps in model theory.
</p>

<p>
Propositional Logic is the logic of combining statements. Propositional logic will also provide a warm up for the richer subject of predicate logic. In Predicate logic we are able to consider statements about real mathematical objects such as groups and rings.
</p>

<p>
Predicate Logic is the logic of quantifiers. This logic allows us to consider statements about real mathematical objects such as groups and rings.
</p>

<p>
Model Theory builds on Predicate Logic.
</p>
<!--
...... subsection Prerequisites and warm-up questions ......
-->
<h5 id="autosec-7">Prerequisites and warm-up questions</h5>
<a id="Logic-autopage-7"></a>


<p>
You won’t need to know much of the <i>content</i> of your previous courses in order to understand this course. However, you will need a level of mathematical maturity which you won’t have unless you have attended them! In particular, you will need to have
experience of the role of definitions in pure mathematics and be comfortable with reading and producing proofs. I will also take some examples from your algebra courses.
</p>

<p>
I have produced some “warm-up” questions for the first week. There won’t be a workshop on these questions but you are very welcome to talk to me about their solutions.
</p>
<!--
...... subsection Mistakes ......
-->
<h5 id="autosec-8">Mistakes</h5>
<a id="Logic-autopage-8"></a>


<p>
If you think you’ve found a mistake in the notes, please send me an email. I’m also happy to hear about typos. If you don’t understand something in these notes (or in lectures) then please send me an email or come to one of my office hours. It is really useful for
me to know what students find difficult to understand or what I might not have explained well.
</p>
<!--
...... subsection Books and other resources ......
-->
<h5 id="autosec-9">Books and other resources</h5>
<a id="Logic-autopage-9"></a>


<p>
Although it is not necessary, I highly recommend taking a look at some books on mathematical logic. Many of them will give more details than I am able to give in lectures and/or different perspectives on the material that you might find helpful (or interesting).
However, you need to approach them in a mature fashion; very few books, if any, will adopt exactly the conventions of this course.
</p>
<!--
...... subsection Plan ......
-->
<h5 id="autosec-10">Plan</h5>
<a id="Logic-autopage-10"></a>


<p>
Here is a plan of how the hours of the course will be used up to reading week.
</p>
<div class="center">
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black"></td>
<td colspan="2" class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Monday</td>
<td colspan="2" class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Thursday</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black"></td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(9-10\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(10-11\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(14-15\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(15-16\)</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black">Wk 1</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black">Wk 2</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L/W</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black">Wk 3</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">W</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black">Wk 4</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">W</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black">Wk 5</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">W</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">L</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Wk 6</td>
<td colspan="4" class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Reading Week</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

</div>

<p>
L = Lecture, W = Workshop
</p>
<!--
...... subsection Coursework ......
-->
<h5 id="autosec-13">Coursework</h5>
<a id="Logic-autopage-13"></a>


<p>
<b>Coursework 1</b>: The first coursework is worth \(10\%\) of the marks for this module. It has \(3\) components:
</p>

<ul class="itemize" style="list-style-type:none">

<li>
<p>
<span class="listmarker">•</span> In-class exercise: label formal propositional logic proof (2&percnt;) [week 3, 4 or 5]
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> In-class exercise: draw a construction tree of a term in predicate logic, compute complexity of a term and give examples of terms of specified complexity in a particular language (2&percnt;) [week 4 or 5 or if needed early
week 7]
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> Written submission to be uploaded to blackboard (6&percnt;)
</p>
</li>
</ul>

<p>
<b>Coursework 2</b>: The first coursework is worth \(10\%\) of the marks for this module. It’s exact form is to be determined but it will be similar to coursework 1.
</p>
<div class="center">

<p>
This page is intentionally blank.
</p>
</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Propositional-Logic.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Propositional Logic</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-15"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Propositional Logic ......
-->
<h4 id="autosec-16"><span class="sectionnumber">2&#x2003;</span>Propositional Logic</h4>
<a id="Logic-autopage-16"></a>
<a id="Logic-autofile-2"></a>
<!--
...... subsection Propositional formulas ......
-->
<h5 id="autosec-17"><span class="sectionnumber">2.1&#x2003;</span>Propositional formulas</h5>
<a id="Logic-autopage-17"></a>


<a id="propflas"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-18"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.1</span></span>. </span> An <b>alphabet</b> of a <b>propositional language</b> \(\mcal {L}\) consists of the following:
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> A set of <b>propositional variables</b> \(\PROP (\mcal {L})\). The elements will usually be denoted \(p,r,q\) or \(p_1,p_2,p_3,\ldots \).
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> A set of <b>connectives</b> \(\{\wedge , \vee , \neg , \rightarrow , \bot \}\).
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> An open bracket “ \((\) ” and a close bracket “ \()\) ” which will collectively be called brackets.
</p>
</li>
</ul>

<p>
We will always assume that \(\PROP (\mcal {L})\) does not contain any connectives or brackets. Each of the connectives has an element of the set \(\{0,1,2\}\) assigned to it which we will call its <b>arity</b>. The connective \(\bot \) has arity
\(0\), the connective \(\neg \) has arity \(1\) and all other connectives listed above have arity \(2\). Connectives with arity \(0\) are called <b>logical constants</b>.
</p>

</li>

</ul>

</div>

<p>
The table below shows useful information about each of the connectives.
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:   1px solid black">Connective</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">Arity</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">Name</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">How to say it.</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">How to LaTeX it.</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">\(\wedge \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(2\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">conjunction</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">and</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black"><span class="verb">\wedge</span></td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">\(\vee \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(2\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">disjunction</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">or</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black"><span class="verb">\vee</span></td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">\(\neg \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(1\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">negation</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">not</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black"><span class="verb">\neg</span></td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">\(\rightarrow \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(2\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">implication</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">implies</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black"><span class="verb">\rightarrow</span></td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">\(\bot \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(0\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">falsity</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">false</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black"><span class="verb">\bot</span></td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-20"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.2</span></span>. </span> A <b>word</b> in (an alphabet of ) a propositional language \(\mcal {L}\) is an \(n\)-tuple of
elements of \(\mcal {L}\). Unusually, we will write the \(n\)-tuple with entries \(a_1,a_2,\ldots , a_n\) as \(a_1a_2\cdots a_n\) rather than \((a_1,\ldots ,a_n)\). The <b>length</b> of a word is simply the length of tuple i.e. the length of
\(a_1a_2\ldots a_n\) is \(n\). We will call the entries of a word \(a=a_1a_2\ldots a_n\) the <b>letters</b> of \(a\).
</p>

</li>

</ul>

</div>

<p>
We define the set of propositional formulas inductively.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-21"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.3</span></span>. </span> Let \(\mcal {L}\) be a propositional language. Define \(\PF _0\mcal {L}\) to be the set of
propositional variables of \(\mcal {L}\) together with the logical constants of \(\mcal {L}\). For each \(i\in \N \), we define \(\PF _i\mcal {L}\) by induction as follows:
</p>

<p>
\[\PF _{i+1}\mcal {L}:= \PF _i\mcal {L}\cup \{(\neg t) \st t\in \PF _i\mcal {L}\} \cup \{(s_1\conn s_2) \st s_1,s_2\in \PF _i\mcal {L} \text { and } \square \text { is a connective of arity } 2\}.\]
</p>

<p>
The set of <b>propositional formulas</b>, denoted \(\PF \mcal {L}\), is the union of the sets \(\PF _i\mcal {L}\) for \(i\in \N _0\). The <b>complexity</b> of a propositional formula \(t\) is the least \(i\in \N _0\) such that \(t\in \PF
_i\mcal {L}\).
</p>

</li>

</ul>

</div>

<p>
Note that the arity of a connective determines how it is used to construct propositional formulas.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-22"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">2.4</span></span>. </span> Let \(\mcal {L}\) be the propositional language with set of propositional variables \(\PROP (\mcal
{L})=\{p\}\). The sets of propositional formulas of complexity \(0\) is
</p>

<p>
\[\PF _0\mcal {L}:=\{p, \bot \}.\]
</p>

<p>
There are \(16\) propositional formulas of complexity \(0\) and \(1\).
</p>
<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>



<!--




  S1 L := {p, ⊥, (¬p), (¬⊥), (p ∧ p), (p ∧ ⊥), (⊥ ∧ p), (⊥ ∧ ⊥),
                                                                                                                                                                 (p ∨ p), (p ∨ ⊥), (⊥ ∨ p), (⊥ ∨ ⊥), (p → p), (p → ⊥), (⊥ → p), (⊥ → ⊥)}.



-->



<p>


\begin{multline*}
\PF _1\mcal {L}:= \{p, \bot , (\neg p), (\neg \bot ), (p\wedge p), (p\wedge \bot ), (\bot \wedge p), (\bot \wedge \bot ), \\ (p\vee p), (p\vee \bot ), (\bot \vee p), (\bot \vee \bot ), (p\rightarrow p),
(p\rightarrow \bot ), (\bot \rightarrow p), (\bot \rightarrow \bot ) \}.
\end{multline*}


</p>

<p>
Here are a few propositional formulas of complexity \(2\):
</p>

<p>
\[((p\wedge p)\rightarrow \bot ), \quad (\neg (\bot \rightarrow \bot )), \quad ((p\wedge p)\rightarrow (p\vee \bot )).         \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-23"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.5</span></span>. </span> The set of propositional formulas \(\PF \mcal {L}\) of a propositional language \(\mcal {L}\) is the
smallest set \(X\) of words in the alphabet of \(\mcal {L}\) satisfying the following properties:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> All propositional variables and logical constants of \(\mcal {L}\) are members of \(X\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \(s\in X\) then \((\neg s)\in X\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> For all connectives \(\square \) of arity \(2\), if \(s_1,s_2\in X\) then \((s_1\square s_2)\in X\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-24"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> See Exercise Sheet \(1\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
For simple expressions like \((p\wedge q)\) and \((\neg (\bot \rightarrow p))\) it is easy argue that they are propositional formulas.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-25"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">2.6</span></span>. </span> Let \(p,q\) be propositional variables of a propositional language \(\mcal {L}\).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> The expression \((p\wedge q)\) is a propositional formula because \(p,q\in \PF _0\mcal {L}\) (since they are propositional variables) and so \((p\wedge q)\in \PF _1\mcal {L}\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> We argue that \((\neg (\bot \rightarrow p))\) is a propositional formula. Since \(p\) is a propositional variable and \(\bot \) is a logical constant, \(p,\bot \in \PF _0\mcal {L}\). Therefore \((\bot
\rightarrow p)\in \PF _1\mcal {L}\). Hence \((\neg (\bot \rightarrow p))\in \PF _2\mcal {L}\).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
Explaining why a complicated expression is a propositional formula as in the previous example can become tedious and difficult to follow. For this reason we introduce construction trees of propositional formulas.
</p>
<!--
...... subsubsection Construction Trees ......
-->
<h6 id="autosec-26">Construction Trees</h6>
<a id="Logic-autopage-26"></a>


<p>
Before explaining what a construction tree is, it is helpful to see some examples. The following is the construction tree of the propositional formula \((p\wedge q)\):
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-1"
    class="lateximagesource"
><!--
    p∧q


p         q
--><img
    src="Logic-images\image-1.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
Here is the construction tree of \((\neg (\bot \rightarrow p))\):
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-2"
    class="lateximagesource"
><!--
(¬(⊥ → p))


 (⊥→p)


 ⊥     p
--><img
    src="Logic-images\image-2.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-33"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.7</span></span>. </span> The <b>construction tree</b> \(CT(t)\) of a propositional formula \(t\) is defined recursively based
on the definition of a propositional formula. The construction tree of a propositional variable \(p\) is:
</p>
<div class="center">

<p>
<span
      id="lateximage-Logic-3"
      class="lateximagesource"
><!--
p
--><img
      src="Logic-images\image-3.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
The construction tree of the logical constant \(\bot \) is:
</p>
<div class="center">

<p>
<span
      id="lateximage-Logic-4"
      class="lateximagesource"
><!--
⊥
--><img
      src="Logic-images\image-4.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
If \(s\) is a propositional formula then \(CT((\neg s))\) is:
</p>
<div class="center">

<p>
<span
      id="lateximage-Logic-5"
      class="lateximagesource"
><!--
(¬s)


CT (s)
--><img
      src="Logic-images\image-5.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
If \(s_1\) and \(s_2\) are propositional formulas and \(\square \) is a connective of arity \(2\) then \(CT((s_1\square s_2))\) is:
</p>
<div class="center">

<p>
<span
      id="lateximage-Logic-6"
      class="lateximagesource"
><!--
    (s1 □s2 )


CT (s1 ) CT (s2 )
--><img
   src="Logic-images\image-6.svg"
   alt="(-tikz-&nbsp;diagram)"
   style=""
   class="lateximage"
></span>
</p>
</div>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-46"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">2.8</span></span>. </span> The following is the construction tree of the propositional formula \((((p_4\rightarrow (\neg
p_1))\wedge p_2)\vee ((\neg p_3)\wedge (p_2\rightarrow \bot )))\).
</p>
<div class="center">

<p>


<a href="Tree1.jpg" target="_blank" ><img
      src="Tree1.jpg"
      class="inlineimage"
      alt="(image)"
></a>
</p>
</div>

<p>
To help you more easily see what is going on, the connective which is introduced at each node is in boldface red.
</p>

</li>

</ul>

</div>

<p>
We will later see an algorithm which given a propositional formula allows you to compute a construction tree for it.
</p>

<p>
<span role="note" class="marginpar">End of L1&amp;L2</span>
</p>
<!--
...... subsubsection Induction on the complexity of propositional formulas ......
-->
<h6 id="autosec-48">Induction on the complexity of propositional formulas</h6>
<a id="Logic-autopage-48"></a>


<p>
We will frequently prove properties of propositional formulas by “induction on complexity”. To prove a statement about all propositional formulas, using this method of proof, we first prove the statement for \(\PF _0\mcal {L}\) (this is our base case) and then
show that, for all \(n\in \N _0\), if the statement holds of \(\PF _n\mcal {L}\) then it also holds for \(\PF _{n+1}\mcal {L}\).
</p>

<p>
Here is a simple first example. Before reading the proof of this lemma, look at the definition of a propositional formula and think about why it is true.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-49"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.9</span></span>. </span> <a id="leftrightbrackets"></a> Let \(\mcal {L}\) be a propositional language. Suppose \(s\in \PF
\mcal {L}\). The number of open brackets \((\) occuring in \(s\) is equal to the number of close brackets \()\) occuring in \(s\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-50"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> For any propositional formula \(s\), define \(l[s]\) (respectively \(r[s]\)) to be the number of open brackets “ \((\) ” (respectively close brackets “ \()\) ”)
occurring in \(s\). If \(s\in \PF _0\mcal {L}\) then \(s\) is either a propositional variable or \(\bot \). So \(l[s]=0=r[s]\). Hence the statement of the lemma is true for all \(s\in \PF _0\mcal {L}\). For the induction step, suppose that for
all \(s\in \PF _n\mcal {L}\), \(l[s]=r[s]\). Let \(t\) be a propositional formula in \(\PF _{n+1}\mcal {L}\). Then, examining the definition of \(\PF _{n+1}\mcal {L}\), either \(t\in \PF _n\mcal {L}\), \(t\) is \((\neg s)\) for some
\(s\in \PF _n\mcal {L}\) or \(t\) is \((s_1\square s_2)\) for some propositional formulas \(s_1,s_2\in \PF _n\mcal {L}\) and some connective \(\square \) of arity \(2\).
</p>

<p>
If \(t\in \PF _n\mcal {L}\) then \(l[t]=r[t]\) by our induction hypothesis.
</p>

<p>
If \(t\) is \((\neg s)\) then \(l[t]=l[(\neg s)]=l[s]+1\) and \(r[t]=r[(\neg s)]=r[s]+1\). By the induction hypothesis, \(l[s]=r[s]\). Therefore \(l[t]=r[t]\).
</p>

<p>
If \(t\) is \((s_1\square s_2)\) for some propositional formulas \(s_1,s_2\in \PF _n\mcal {L}\) and some connective \(\square \) of arity \(2\) then \(l[(s_1\square s_2)]=l(s_1)+l(s_2)+1\) and \(r[(s_1\square
s_2)]=r[s_1]+r[s_2]+1\). By the induction hypothesis \(l[s_1]=r[s_1]\) and \(l[s_2]=r[s_2]\). Therefore
</p>

<p>
\[l[t]=l[(s_1\square s_2)]=l[s_1]+l[s_2]+1=r[s_1]+r[s_2]+1=r[(s_1\square s_2)]=r[t].\]
</p>

<p>
Thus we have proved the inductive step. Hence the lemma holds by induction on the complexity of propositional formulas. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We now state a “meta” theorem. The reason it is “meta” is that we deliberately don’t define what we mean by “property”. It is intended to give a template for what needs to be shown in order to prove something by induction on complexity of formulas.
</p>

<p>
For a property \(X\) of propositional formulas and, in this instance, a propositional formula \(t\), we will write \(X(t)\) to mean that property \(X\) holds for \(t\). For example, \(X\) could be the property that \(t\) has the same number of open brackets as
close brackets as in the previous lemma.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-51"></a>
<span class="amsthmnameplain">Meta Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.10</span></span>. </span> Let \(X\) be a property of propositional formulas and let \(\mcal {L}\) be a propositional
language. Suppose that the following hold:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> For all propositional variables \(p\), \(X(p)\) and \(X(\bot )\).
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> For all \(s\in \PF \mcal {L}\), if \(X(s)\) then \(X((\neg s))\).
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> For all \(s_1,s_2\in \PF \mcal {L}\), \(X(s_1)\) and \(X(s_2)\) implies \(X(s_1\wedge s_2)\).
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> For all \(s_1,s_2\in \PF \mcal {L}\), \(X(s_1)\) and \(X(s_2)\) implies \(X(s_1\vee s_2)\).
</p>


</li>
<li>


<p>
<span class="listmarker">5.</span> For all \(s_1,s_2\in \PF \mcal {L}\), \(X(s_1)\) and \(X(s_2)\) implies \(X(s_1\rightarrow s_2)\).
</p>
</li>
</ul>

<p>
Then \(X(t)\) for all \(t\in \PF \mcal {L}\).
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Unique construction ......
-->
<h6 id="autosec-52">Unique construction</h6>
<a id="Logic-autopage-52"></a>


<p>
The next theorem essentially says that every propositional formula has a unique construction tree.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-53"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.11</span></span><span class="amsthmnoteplain"> (Unique Construction Theorem)</span>. </span> <a id="UCProp"></a> For
any propositional formula \(t\), exactly one of the following is true:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(t\) is a propositional variable.
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(t\) is \(\bot \).
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(t\) is of the form \((\neg s)\) for a unique propositional formula \(s\).
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> \(t\) is of the form \((s_1\conn s_2)\) for a unique connective \(\conn \) of arity \(2\) and a unique pair of propositional formulas \((s_1,s_2)\).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
Without the “exactly one” and “unique”, the theorem easily follows from the definition of a propositional formula. To deal with the uniqueness part, we need some definitions and a lemma.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-54"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.12</span></span>. </span> Let \(x\) be a word in a propositional language \(\mcal {L}\). If \(x\) is of the form \(yz\) for
words \(y\) and \(z\) in \(\mcal {L}\) then we call \(y\) a <b>proper left subword</b> of \(x\). A word is a <b>left subword</b> of \(x\) if it is either equal to \(x\) or is a proper left subword of \(x\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-55"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.13</span></span>. </span> <a id="leftsubwords"></a> Let \(\mcal {L}\) be a propositional language and let \(t\in \PF \mcal
{L}\). If \(w\) is a proper left subword of \(t\) then \(l(w)&lt;r(w)\) where \(l(w)\) denotes the number of open brackets occurring in \(w\) and \(r(w)\) denotes the number of close brackets occurring in \(w\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-56"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We prove the statement by induction on the complexity of \(t\). If \(t\in \PF _0\mcal {L}\) then \(t\) has no proper left subwords. So the statement is
vacuously true. We now prove the induction step. Suppose that the statement is true for propositional formulas in \(\PF _i\mcal {L}\). Take \(t\in \PF _{i+1}\mcal {L}\backslash \PF _i\mcal {L}\). We now have \(2\) cases to consider. If
\(t\) is \((\neg s)\) for some \(s\in \PF _i\mcal {L}\) and \(w\) is a proper left subword of \(t\) then either \(w\) is \((\), \((\neg \) or \((\neg y\) where \(y\) is a left subword of \(s\). It’s clear that \(l(w)&gt;r(w)\) in the first \(2\)
cases. So suppose that \(t\) is \((\neg y\) for \(y\) a left subword of \(s\). By the induction hypothesis and <a href="Propositional-Logic.html#leftrightbrackets">2.9</a>, \(l(y)\geq r(y)\). Therefore \(l((\neg y)=1+l(y)\geq
1+r(y)&gt;r(y)=r((\neg y)\) as required.
</p>

<p>
If \(t\) is of the form \((s_1\square s_2)\) for \(s_1,s_2\in \PF _i\mcal {L}\) and \(w\) is a proper left subword of \(t\) then either \(w\) is \((\), \((y\) where \(y\) is a left subword of \(s_1\), \((s_1\square \) or \((s_1\square z\) where
\(z\) is a left subword of \(s_2\). If \(w\) is \((\) then \(l(w)=1&gt;0=r(w)\). If \(y\) is a left subword of \(s_1\) then by the induction hypothesis and <a href="Propositional-Logic.html#leftrightbrackets">2.9</a>, we know that
\(l(y)\geq r(y)\). Therefore \(l((y)=l(y)+1&gt;r(y)=r((y)\) and \(l((y\square )=l(y)+1&gt;r(y)=r((y\square )\) as required. We now suppose that \(z\) is a subword of \(s_2\). Then \(l(z)\leq r(z)\) by <a
href="Propositional-Logic.html#leftrightbrackets">2.9</a> and the induction hypothesis. So
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<p>


\begin{eqnarray*}
l((s_1\square z) &amp;=&amp; 1+l(s_1)+l(z) \\ &amp;=&amp; 1+ r(s_1)+l(z) \qquad \text {(by \ref {leftrightbrackets})}\\ &amp;\geq &amp; 1 + r(s_1)+r(z) \\ &amp;=&amp; 1+ r((s_1\square z) \\ &amp;&gt;&amp;
r((s_1\square z)
\end{eqnarray*}


</p>

<p>
as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
For future use we record the following remark.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-57"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.14</span></span>. </span> <a id="startofpropfla"></a>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(a)</span> The first letter of any propositional formula is either “\((\)”, a propositional variable or \(\bot \).
</p>


</li>
<li>


<p>
<span class="listmarker">(b)</span> All propositional formulas of length \(\geq 2\), start as \((\neg \), \(((\), \((p\) or \((\bot \) where \(p\) is a propositional variable.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-58"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (a) Let \(t\in \PF \mcal {L}\). If \(t\in \PF _0\mcal {L}\) then the first and only letter of \(t\) is a propositional variable or \(\bot \). Otherwise, it
follows directly from the definition of a propositional formula that the first letter of \(t\) is \((\).
</p>

<p>
(b) All propositional formulas not in \(\PF _0\mcal {L}\) are of the form \((\neg s)\) or \((s_1\conn s_2)\) where \(s_1\) and \(s_2\) are propositional formulas and \(\conn \) is a connective of arity \(2\). Formulas of the form \((\neg s)\)
are as described by the statement of the lemma, so we just need to consider those of the form \((s_1\conn s_2)\). The second letter of \((s_1\conn s_2)\) is the first letter of \(s_1\). The statement now follows from (a). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We are now ready to prove the Unique Construction Theorem.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-59"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of the Unique Construction Theorem. </span></span> It follows from the definition of a propositional formula that each propositional formula is of one of the required forms.
</p>

<p>
Clearly a propositional formula which satisfies \(1\) or \(2\) does not satisfy any of the other cases. If a propositional formula satisfies \(3\) then its first \(2\) letters are \((\neg \). If a propositional formula satisfies \(4\) then its first \(2\) letters
are either \(((\), \((p\) or \((\bot \) for \(p\in \PROP (\mcal {L})\). Thus no propositional formula can satisfy \(3\) and \(4\).
</p>

<p>
We now just need to show the uniqueness in \(3\) and \(4\). If \(t\) is \((\neg s)\) and \((\neg s&apos;)\) for propositional formulas \(s\) and \(s&apos;\). Then clearly \(s=s&apos;\). So we consider the case where \(t\) is \((s_1\square
s_2)\) and \((s_1&apos;\square &apos;s_2&apos;)\). Then either \(s_1\) is a left subword of \(s_1&apos;\) or \(s_1&apos;\) is a left subword of \(s_1\). Without loss of generality, suppose \(s_1\) is a left subword of \(s_1&apos;\). If \(s_1\)
is a proper left subword then the number of open brackets of \(s_1\) is strictly greater than the number of close brackets of \(s_1\). But since \(s_1\) is a propositional formula, its number of open brackets is equal to its number of close brackets.
Therefore \(s_1=s_1&apos;\). It now follows that \(\square =\square &apos;\) and then that \(s_2=s_2&apos;\) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection An algorithm to compute the construction tree of a propositional formula ......
-->
<h6 id="autosec-60">An algorithm to compute the construction tree of a propositional formula</h6>
<a id="Logic-autopage-60"></a>


<p>
When we introduced construction trees we saw the construction tree of the propositional formula \((((p_4\rightarrow (\neg p_1))\wedge p_2)\vee ((\neg p_3)\wedge (p_2\rightarrow \bot )))\). Given the construction tree it was reasonably easy
to check it was correct and hence confirm that \((((p_4\rightarrow (\neg p_1))\wedge p_2)\vee ((\neg p_3)\wedge (p_2\rightarrow \bot )))\) is indeed a propositional formula. We will now see an algorithm to compute the construction tree of a
propositional formula based on the proof of the Unique Construction Theorem.
</p>

<p>
<b>Case 0:</b> If a propositional formula is in \(\PF _0\mcal {L}\) then we just write down the formula.
</p>

<p>
For propositional formulas not in \(\PF _0\mcal {L}\), we split into \(3\) cases suggested by <a href="Propositional-Logic.html#startofpropfla">2.14</a>.
</p>

<p>
<b>Case 1:</b> The first \(2\) letters of \(t\) are \((\neg \).
</p>

<p>
In this case \(t\) is of the form \((\neg s)\) and the construction tree starts:
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-7"
    class="lateximagesource"
><!--
(¬s)


 s
--><img
    src="Logic-images\image-7.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
To continue, we now just need to find the construction tree of \(s\).
</p>

<p>
<b>Case 2:</b> The first \(2\) letters of \(t\) are “\((p\)” or “\((\bot \)” for some propositional variable \(p\).
</p>

<p>
In this case \(t\) is of the form \((p\conn s)\) or \((\bot \conn s)\) for some propositional formula \(s\) and connective \(\square \) of arity \(2\). So the construction tree starts respectively:
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-8"
    class="lateximagesource"
><!--
(p □ s)


p     s
--><img
    src="Logic-images\image-8.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span> &#x2003;&#x2003;&#x2003;&#x2003;<span
    id="lateximage-Logic-9"
    class="lateximagesource"
><!--
(⊥ □ s)


⊥     s
--><img
    src="Logic-images\image-9.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
<b>Case 3:</b> The first \(2\) letters of \(t\) are “\(((\)”.
</p>

<p>
In this case \(t\) is of the form \((s_1\conn s_2)\) and the first letter of \(s_1\) is \((\). So the construction tree of \(t\) starts:
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-10"
    class="lateximagesource"
><!--
(s1 □ s2 )


s1      s2
--><img
    src="Logic-images\image-10.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
But how do we find \(s_1\), \(\conn \) and \(s_2\)?
</p>

<p>
Since the first letter of \(s_1\) is \((\), \(s_1\) is not in \(\PF _0\mcal {L}\). By <a href="Propositional-Logic.html#leftsubwords">2.13</a>, for all proper left subwords \(y\) of \(s\), the number of open brackets in \(y\) is strictly less than the
number of close brackets in \(y\). Thus \(s_1\) is the shortest left subword of \(s_1\square s_2)\) with equal number of open and close brackets.
</p>

<p>
Hence, in order to find \(s_1\), we <i>just</i> need to count open and close brackets in \((s_1\conn s_2)\) to compute the last close bracket in \(s_1\).
</p>

<p>
We number the first (open) bracket in \((s_1\conn s_2)\) with \(1\). We continue from left to right labelling each open bracket with \(i+1\) if the previous bracket was labelled \(i\) and each close bracket \(i-1\) if the previous bracket was labelled
\(i-1\). We continue until we label a close bracket with a \(1\). Then \(s_1\) is the formula starting with the open bracket labelled \(2\) and ending with the close bracket labelled \(1\).
</p>

<p>
This process is easier to understand once you have seen an example. Consider the propositional formula
</p>

<p>
\[(((\neg p)\rightarrow ((p\rightarrow (\neg q))\rightarrow (\neg r)))\rightarrow (p\rightarrow r)).\]
</p>

<p>
Assuming this is indeed a propositional formula, we know that it is the form \((s_1\conn s_2)\) and we want to find \(s_1\), \(\conn \) and \(s_2\). Here is the propositional formula with the brackets numbered:
</p>

<p>
\[\underset {1}{(}\underset { 2}{(}\underset {3}{(}\neg p\underset { 2}{)}\rightarrow \underset {3}{(}\underset { 4}{(}p\rightarrow \underset { 5}{(}\neg q\underset {4}{)}\underset {3}{)}\rightarrow \underset
{4}{(}\neg r\underset { 3}{)}\underset { 2}{)}\underset { 1}{)}\rightarrow (p\rightarrow r))\]
</p>

<p>
Here it is with \(s_1\) and \(s_2\) labelled:
</p>

<p>
\[\underset {1}{(}\overbrace {\underset { 2}{(}\underset {3}{(}\neg p\underset { 2}{)}\rightarrow \underset {3}{(}\underset { 4}{(}p\rightarrow \underset { 5}{(}\neg q\underset {4}{)}\underset {3}{)}\rightarrow
\underset {4}{(}\neg r\underset { 3}{)}\underset { 2}{)}\underset { 1}{)}}^{s_1}\rightarrow \overbrace {(p\rightarrow r)}^{s_2})\]
</p>

<p>
The last connective introduced in the construction of \((s_1\square s_2)\) is \(\rightarrow \) i.e. \(\square \) is \(\rightarrow \) and \(s_2\) is \((p\rightarrow r)\).
</p>

<p>
So the start of the construction tree is
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-11"
    class="lateximagesource"
><!--
    (((¬p) → ((p → (¬q)) → (¬r))) → (p → r))


((¬p) → ((p → (¬q)) → (¬r)))   (p → r)
--><img
    src="Logic-images\image-11.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
<span role="note" class="marginpar">End of L3&amp;L4</span>
</p>

<p>
We will now see a(n almost) full worked example of applying the construction tree algorithm to the propositional formula \((((\neg p)\rightarrow ((p\rightarrow (\neg q))\rightarrow (\neg r)))\rightarrow (p\rightarrow r))\).
</p>

<p>
REPLACE WITH PDF
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-12"
    class="lateximagesource"
><!--
p   (¬q)   r


     q
--><img
    src="Logic-images\image-12.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
\(\bm {(1)}\) The propositional formula \((((\neg p)\rightarrow ((p\rightarrow (\neg q))\rightarrow (\neg r)))\rightarrow (p\rightarrow r))\) starts with \(((\) so we apply case \(3\) and count the brackets. We’ve already done this step
when describing the algorithm.
</p>

<p>
\(\bm {(2)}\) The propositional formula \(((\neg p)\rightarrow ((p\rightarrow (\neg q))\rightarrow (\neg r)))\) starts with \(((\) so we apply case \(3\) and count the brackets as follows:
</p>

<p>
\[\underset {1}{(}\underset {2}{(}\neg p\underset {1}{)}\rightarrow ((p\rightarrow (\neg q))\rightarrow (\neg r)))\]
</p>

<p>
So we get the construction tree
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-13"
    class="lateximagesource"
><!--
((¬p) → ((p → (¬q)) → (¬r)))


 (¬p)          ((p → (¬q)) → (¬r))
--><img
    src="Logic-images\image-13.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
\(\bm {(3)}\) The propositional formula \((\neg p)\) starts with \((\neg \) so we apply case \(1\) and get the construction tree
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-14"
    class="lateximagesource"
><!--
(¬p)


 p
--><img
    src="Logic-images\image-14.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
\(\bm {(4)}\) The propositional formula \(((p\rightarrow (\neg q))\rightarrow (\neg r))\) starts with \(((\) so we apply case \(3\) and count brackets as follows:
</p>

<p>
\[\underset {1}{(}\underset {2}{(}p\rightarrow \underset {3}{(}\neg q\underset {2}{)}\underset {1}{)}\rightarrow (\neg r))\]
</p>

<p>
So we get the construction tree
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-15"
    class="lateximagesource"
><!--
      ((p → (¬q)) → (¬r))


(p → (¬q))              (¬r)
--><img
    src="Logic-images\image-15.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
\(\bm {(5)}\) The propositional formula \((p\rightarrow (\neg q))\) starts with \((p\) and \(p\) is a propositional variable so we apply case \(2\) and get the construction tree
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-16"
    class="lateximagesource"
><!--
    (p → (¬q))


p                (¬q)
--><img
    src="Logic-images\image-16.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
\(\bm {(6)}\) and \(\bm {(7)}\) are like \(\bm {(3)}\).
</p>

<p>
\(\bm {(8)}\) The propositional formula \((p\rightarrow r)\) starts with \((p\) and \(p\) is a propositional variable so we apply case \(2\) and get the construction tree
</p>
<div class="center">

<p>
<span
    id="lateximage-Logic-17"
    class="lateximagesource"
><!--
    (p → r)


p             r
--><img
    src="Logic-images\image-17.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-93"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.15</span></span>. </span> Although I haven’t justified this, if the construction tree algorithm goes wrong at any point then the word
we started with is not a propositional formula. This roughly follows from the proof of the unique readability theorem. This is important because it means a computer can not only compute construction trees but determine whether a word is a
propositional formula or not.
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Truth.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Truth</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-94"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Truth ......
-->
<h5 id="autosec-95"><span class="sectionnumber">2.2&#x2003;</span>Truth</h5>
<a id="Logic-autopage-95"></a>
<a id="Logic-autofile-3"></a>

<a id="truth"></a>

<p>
The truth of the statement “\(5\) is an odd number and \(7\) is prime” does not really depend on exactly the statements “\(5\) is an odd number” and “\(7\) is prime”. What is important is that both “\(5\) is an odd number” and is true “\(7\) is prime” are
true statements.
</p>

<p>
The truth of a propositional formula should only depend on the truth of the propositional variables it is made up from. Although we have not formally assigned any meaning to connectives, the names we have given indicate what meaning we might want them to
have.
</p>

<p>
In the following definition the symbol \(\T \) represents “true” and \(\F \) represents “false”. We think of the valuation \(v\) as telling us which propositional formulas are true and which are false according to \(v\).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-96"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.16</span></span>. </span> A <b>valuation</b> is a function \(v:\PF \mcal {L}\rightarrow \{\T ,\F \}\) which satisfies the
following properties for all \(s,t\in \PF \mcal {L}\):
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(v(\bot )=\F \)
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(v((\neg s))=\left \{ \begin {array}{ll} \F , &amp; \hbox {if $v(s)=\T $;} \\ \T , &amp; \hbox {otherwise.} \end {array} \right .                                           \)
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(v((t\wedge s))=\left \{ \begin {array}{ll} \T , &amp; \hbox {if $v(t)=\T $ and $v(s)=\T $;} \\ \F , &amp; \hbox {otherwise.} \end {array} \right .                                                  \)
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> \(v((t\vee s))=\left \{ \begin {array}{ll} \F , &amp; \hbox {if $v(s)=\F $ and $v(t)=\F $;} \\ \T , &amp; \hbox {otherwise.} \end {array} \right .                                               \)
</p>


</li>
<li>


<p>
<span class="listmarker">5.</span> \(v((s\rightarrow t))=\left \{ \begin {array}{ll} \F , &amp; \hbox {$v(s)=\T $ and $v(t)=\F $;} \\ \T , &amp; \hbox {otherwise.} \end {array} \right .                                                     \)
</p>
<p>


</p>
</li>
</ul>

<p>
We say that a propositional formula \(s\in \PF \mcal {L}\) is <b>true (respectively false) under the valuation</b> \(v\) if \(v(s)=\T \) (respectively if \(v(s)=\F \)).
</p>

</li>

</ul>

</div>

<p>
The least controversial parts of this definition are for the connectives are \(\wedge \) (and) and \(\neg \) (not). We have already discussed \(\wedge \) (and). I hope you agree that if a statement is true then its negation should be false and conversely if a
statement is false then its negation should be true. For example the statement “All mathematicians are female” is false and so its negation “Not all mathematicians are female” is true.
</p>

<p>
We now discuss “\(\vee \)” (or). In everyday life “or” is often treated a exclusive. However, in mathematics, “or” is usually meant non-exclusively. This give rise to the following (not funny) mathematician’s/logician’s joke:
</p>

<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker">unsuspecting member of the non-mathematical population:</span> Would you like a cup of coffee or a cup of tea?
</p>

</li>
<li>

<p>
<span class="listmarker">mathematician/logician:</span> Yes, please.
</p>
</li>
</ul>

<p>
The most controversial part of this definition is the condition for \(\rightarrow \) (implies). As with “or” we could just say this is our convention, get used to it. Since our intention is to give a formal definition of truth, this would be a bit unsatisfactory. First
note that this definition does not match up with informal speech even amongst mathematicians. For instance, if I claimed that
</p>
<div class="center">

<p>
“The first isomorphism theorem for groups implies the intermediate value theorem (for continuous functions).”
</p>
</div>

<p>
many of my colleagues and your lecturers would reasonably disagree. On the other hand, most of us would accept that
</p>
<div class="center">

<p>
“If \(n=1\) then \((n-1)(n-2)=0\)”
</p>
</div>

<p>
is true for all \(n\in \N \). Although we are not yet studying a logic with quantifiers, it becomes clear that the rule for implication must be as we have defined it when we consider statements involving universal quantification (i.e. “for all” statements) like the
following.
</p>

<p>
\[\forall \, x ((x&gt;3)\rightarrow (x^2&gt;3))\]
</p>

<p>
This statement is true if for each \(r\in \R \), the statement “\(((r&gt;3)\rightarrow (r^2&gt;3))\)” is true. If we set \(r=1\) then \((r&gt;3)\) is false and \(r^2&gt;3\) is false. If we set \(r=2\) then \(r&gt;3\) is false and \(r^2&gt;3\) is true. If
we set \(r=4\) then \(r&gt;3\) is true and \(r^2&gt;3\) is also true.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-99"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.17</span></span>. </span> Let \(\mcal {L}\) be a propositional language.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> If \(w:\PROP (\mcal {L})\rightarrow \{\T ,\F \}\) is any function then there is a unique valuation \(\PF \mcal {L}\rightarrow \{\T ,\F \}\) such that \(v(p)=w(p)\) for all \(p\in \PROP (\mcal
{L})\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \(t\in \PF \mcal {L}\) and \(v,w\) are valuations which agree on all of the propositional variables occurring in \(t\) then \(v(t)=w(t)\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-100"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Sketch proof.</span></span> (i) Let \(w:\PROP (\mcal {L})\rightarrow \{\T ,\F \}\). For each \(i\in \N _0\), we define \(v_i:\PF _i\mcal {L}\rightarrow \{\T ,\F \}\), by
induction on \(i\), which satisfies properties \(1\)-\(5\) of the definition of a valuation and such that \(v_i(p)=w(p)\) for all \(p\in \PROP (\mcal {L})\). For each \(i\in \N _0\), \(v_{i+1}\) will be the unique such function extending \(v_i\).
</p>

<p>
We define \(v_0\) by setting \(v_0(p)=w(p)\) for all \(p\in \PROP (\mcal {L})\). In order that \(v_0\) satisfies \(1\)-\(5\), we must define \(v_0(\bot )=\F \).
</p>

<p>
Suppose we have already defined \(v_i:\PF _i\mcal {L}\rightarrow \{\T ,\F \}\). Each element of \(\PF _{i+1}\mcal {L}\) is either in \(\PF _i\mcal {L}\) or is of the form \((\neg s)\) or \((s_1\conn s_2)\) for some \(s, s_1,s_2\in
\PF _i\mcal {L}\) and connective \(\conn \) of arity \(2\). For each connective extend \(v_i\) according to the rules for that connective given in the definition of a valuation. For instance, if \(t=(\neg s)\) then define \(v_{i+1}(t)=\F \) if
\(v_i(s)=\T \) and define \(v_{i+1}(t)=\T \) if \(v_i(s)=\F \). The function \(v_{i+1}\) is well-defined thanks to the Unique Construction Theorem. Moreover \(v_{i+1}\) is the unique function defined on \(\PF _{i+1}\mcal {L}\) satisfying
\(1\)-\(5\) of the definition of a valuation. Let \(v:\PF \mcal {L}\rightarrow \{\T ,\F \}\) be defined by \(v(s)=v_i(s)\) for each \(s\in \PF _i\mcal {L}\). Then \(v\) satisfies \(1\)-\(5\) of the definition of a valuation because each
\(v_i\) does. Moreover it is the unique valuation extending \(w\) because each \(v_i\) is the unique function defined on \(\PF _i\mcal {L}\) which satisfies \(1\)-\(5\) and extends \(w\).
</p>

<p>
(ii) This is left as an exercise. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The rules for valuations are displayed in the following two (truth) tables:
</p>
<div class="center">
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarrdouble" style="border-left: 1px solid black; border-right:   4px double black">\(p\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\((\neg p)\)</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarrdouble" style="border-left: 1px solid black; border-right:   4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarrdouble" style="border-left: 1px solid black; border-right:   4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<p>
&#x2003;&#x2003;&#x2003;&#x2003;
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">\(p\)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(q\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(p\wedge q\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(p\vee q\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(p\rightarrow q\)</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

</div>

<p>
We have seen that if \(s\in \PF \mcal {L}\) and \(v\) is a valuation on \(\PF \mcal {L}\) then the value of \(v(s)\) only depends on the value of \(v(p)\) for propositional variables which occur in \(s\) (i.e. are letters of \(s\)).
</p>

<p>
Suppose that the propositional variables which occur in \(s\in \PF \mcal {L}\) are \(p_1,\ldots ,p_n\). A <b>truth table</b> for \(s\) is a table with columns headed \(p_1, p_2,\ldots ,p_n, s\). If we ignore the column headed \(s\) then the rows
of the table display all possible configurations of \(\T \) and \(\F \). The entry of each row of the column labelled \(s\) displays the value of \(v(s)\) for a valuation with \(v(p_i)\) equal to the \(i\)th entry of that row.
</p>

<p>
Here is an example of a truth table.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-104"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">2.18</span></span>. </span>
</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(p_1\)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(p_2\)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(p_3\)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\((p_1\rightarrow (p_2\wedge p_3))\)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:   1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:   4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-106"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.19</span></span>. </span> A propositional formula \(t\) is called a <b>tautology</b> if \(v(t)=\T \) for all valuations \(v\)
and <b>unsatisfiable</b> if \(v(t)=\F \) for all valuations \(v\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-107"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.20</span></span>. </span> To check if a propositional formula \(t\) is a tautology we just need to check that \(v(t)=\T \) for
valuations on the language with propositional variables occurring in \(t\).
</p>

<p>
For examples, to check if \(((p_1\vee (\neg p_1))\vee p_2)\) is a tautology, we only need to consider valuations on \(\PF \mcal {L}&apos;\) where \(\mcal {L}&apos;\) is the propositional language with \(\PROP (\mcal
{L}&apos;)=\{p_1,p_2\}\).
</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L5&amp;L6</span>
</p>

<p>
A propositional formula \(s\) is a tautology if the column in its truth table headed \(s\) has all entries \(\T \). We give a few tautologies which will be important for the proof system we will introduce in the next section.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-108"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.21</span></span>. </span> <a id="axiomsaretaut"></a> For all propositional formulas \(r, s\) and \(t\), the following
propositional formulas are tautologies.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \((s\rightarrow (t\rightarrow s))\)
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> \(((s\rightarrow (t\rightarrow r))\rightarrow ((s\rightarrow t)\rightarrow (s\rightarrow r)))\)
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> \(((\neg (\neg s))\rightarrow s)\)
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-109"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (i) The following truth table shows that the propositional formula \((s\rightarrow (t\rightarrow s))\) is a tautology for any propositional formulas \(s\)
and \(t\).
</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:         1px solid black; border-right:   1px solid black">\(s\)</td>
<td class="tdc tvertbarrdouble" style="border-right:         4px double black">\(t\)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\((t\rightarrow s)\)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\((s\rightarrow (t\rightarrow s))\)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:         1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:         4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:         1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:         4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:         1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:         4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:         1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:         4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:        1px solid black">\(\T \)</td>
</tr>


<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<p>
(ii) This is on your exercise sheet.
</p>

<p>
(iii) The following truth table shows that \(((\neg (\neg s))\rightarrow s)\) is a tautology.
</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarrdouble" style="border-left:   1px solid black; border-right:   4px double black">\(s\)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\((\neg s)\)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\((\neg (\neg s))\)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(((\neg (\neg s))\rightarrow s)\)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarrdouble" style="border-left:   1px solid black; border-right:   4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarrdouble" style="border-left:   1px solid black; border-right:   4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:   1px solid black">\(\T \)</td>
</tr>


<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We introduce a useful abbreviation.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-112"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.22</span></span>. </span> For all propositional formulas \(t\) and \(s\), define \((t\leftrightarrow s)\) to be the
propositional formula \(((t\rightarrow s)\wedge (s\rightarrow t))\). We call the symbol \(\leftrightarrow \) biimplication.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-113"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.23</span></span>. </span>
</p>

<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> For all propositional formulas \(t\) and \(s\),
</p>
<p>
\(v((t\leftrightarrow s))=\left \{ \begin {array}{ll} \T , &amp; \hbox {if $v(t)=v(s)$;} \\ \F , &amp; \hbox {otherwise.} \end {array} \right .                 \)
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> If \(s,t\) are propositional formulas of complexity \(l\) and \(m\) respectively then the complexity of \((t\leftrightarrow s)\) is \(\max \{l,m\}+2\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-114"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.24</span></span>. </span> Let \(\mcal {L}\) be a propositional language, let \(t\in \PF \mcal {L}\) and let \(S\subseteq \PF
\mcal {L}\). We write \(S\models t\) and say \(S\) <b>logically implies</b> \(t\) (or \(t\) <b>is a logical consequence of</b> \(S\)) if \(v(t)=\T \) for all valuations \(v\) such that \(v(s)=\T \) for all \(s\in S\).
</p>

</li>

</ul>

</div>

<p>
If \(S\subseteq \PF \mcal {L}\) and \(t_1,\ldots ,t_n,u\in \PF \mcal {L}\) then we, abuse notation and, write \(S,t_1,\ldots ,t_n\models u\) instead of \(S\cup \{t_1,\ldots ,t_n\}\models u\) and \(t_1,\ldots ,t_n\models u\)
instead of \(\{t_1,\ldots ,t_n\}\models u\). Under this convention, \(\models u\) means \(u\) is a tautology.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-115"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">2.25</span></span>. </span> For a set of propositional formulas \(S\), \(S\models \bot \) means that there are no valuations for
which \(v(s)=\T \) for all \(s\in S\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-116"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.26</span></span>. </span> <a id="modimp"></a> If \(S\models t\) and \(S\models (t\rightarrow u)\) then \(S\models u\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-117"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose \(S\models t\) and \(S\models (t\rightarrow u)\). Let \(v\) be a valuation such that \(v(s)=\T \) for all \(s\in S\). So \(v(t)=\T \) and
\(v(t\rightarrow u)=\T \). If \(v(u)=\F \) then, since \(v(t)=\T \), \(v(t\rightarrow u)=\F \) which contradicts our assumptions. Therefore \(v(u)=\T \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-118"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.27</span></span>. </span> We say propositional formulas \(s\) and \(t\) are <b>logically equivalent</b>, and write \(s\equiv
t\), if \(v(s)=v(t)\) for all valuations \(v\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-119"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.28</span></span>. </span> For a propositional language \(\mcal {L}\), the relation \(\equiv \) is an equivalence relation on \(\PF
\mcal {L}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-120"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.29</span></span>. </span> For propositional formulas \(r,s,t\), the following logical equivalences hold.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \((\neg s)\equiv (s\rightarrow \bot )\)
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \((s\vee t)\equiv ((\neg s)\rightarrow t)\equiv ((s\rightarrow \bot )\rightarrow t)\)
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \((s\wedge t)\equiv (\neg (s\rightarrow (\neg t)))\)
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> \((s\wedge t)\equiv (t\wedge s)\)
</p>


</li>
<li>


<p>
<span class="listmarker">5.</span> \((s\vee t)\equiv (t\vee s)\)
</p>


</li>
<li>


<p>
<span class="listmarker">6.</span> \((\neg (s\wedge t))\equiv ((\neg s)\vee (\neg t))\)
</p>


</li>
<li>


<p>
<span class="listmarker">7.</span> \((s\wedge t)\equiv (\neg ((\neg s)\vee (\neg t)))\)
</p>


</li>
<li>


<p>
<span class="listmarker">8.</span> \(((r\wedge s)\wedge t)\equiv (r\wedge (s\wedge t))\)
</p>


</li>
<li>


<p>
<span class="listmarker">9.</span> \(((r\vee s)\vee t)\equiv (r\vee (s\vee t))\)
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-121"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> These equivalences can be checked using truth tables. Here is an example.
</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:      1px solid black; border-right:    1px solid black">\(s\)</td>
<td class="tdc tvertbarrdouble" style="border-right:     4px double black">\(t\)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\((s\vee t)\)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\((t\vee s)\)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-top:      4px double; border-left:    1px solid black; border-right:    1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-top:     4px double; border-right:    4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-top:     4px double; border-right:    1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-top:     4px double; border-right:    1px solid black">\(\T \)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:      1px solid black; border-right:    1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:     4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\(\T \)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:      1px solid black; border-right:    1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:     4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\(\T \)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:      1px solid black; border-right:    1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:     4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:     1px solid black">\(\F \)</td>
</tr>


<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<p>
We see that \((s\vee t)\equiv (t\vee s)\) because the column headed \((s\vee t)\) and the column headed \((t\vee s)\) are equal.
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-123"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.30</span></span>. </span> Suppose that \(s,t\in \PF \mcal {L}\). The following are equivalent.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(s\equiv t\);
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(s\models t\) and \(t\models s\);
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(\models s\leftrightarrow t\); and
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> \(s\leftrightarrow t\) is a tautology.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-124"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Exercise (mainly in remembering definitions). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Normal Forms ......
-->
<h5 id="autosec-125">Normal Forms</h5>
<a id="Logic-autopage-125"></a>


<p>
We introduce some useful notation defined by induction. Define \(\bigwedge _{i=1}^1 s_1\) to be \(s_1\) and \(\bigvee _{i=1}^1s_1\) to be \(s_1\). For \(k\in \N \), we define
</p>

<p>
\[\bigwedge _{i=1}^{k+1}s_i \quad \text { to be }\quad (\left (\bigwedge _{i=1}^{k}s_i\right )\wedge s_{k+1}) \qquad \text { and }\qquad \bigvee _{i=1}^{k+1}s_i \quad \text { to be }\quad (\left (\bigvee
_{i=1}^{k}s_i\right )\vee s_{k+1}).\]
</p>

<p>
We record how these new symbols behave with respect to valuations and logical equivalence.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-126"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.31</span></span>. </span> Let \(s_1,\ldots , s_n\in \PF \mcal {L}\) and let \(v:\PF \mcal {L}\rightarrow \{\T ,\F \}\)
be a valuation. Then
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(v(\bigwedge _{i=1}^ns_i)=\T \) if and only if \(v(s_i)=\T \) for all \(i=1,\ldots ,n\);
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(v(\bigvee _{i=1}^ns_i)=\T \) if and only if \(v(s_i)=\T \) for some \(i=1,\ldots ,n\);
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(\bigwedge _{i=1}^ns_i\equiv (\neg \bigvee _{i=1}^n (\neg s_i))\); and
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> \(\bigvee _{i=1}^ns_i\equiv (\neg \bigwedge _{i=1}^n (\neg s_i))\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-127"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Each statement is proved by induction on \(n\). I will prove the first statement. For \(n=1\) the statement is trivial since \(\bigwedge _{i=1}^1s_i\) is
\(s_1\). Suppose the statement is true for \(n\). Then \(\bigwedge _{i=1}^{n+1}s_i\) is \(((\bigwedge _{i=1}^ns_i)\wedge s_{n+1})\). So \(v(\bigwedge _{i=1}^{n+1}s_i)=\T \) if and only if \(v(\bigwedge _{i=1}^ns_i)=\T \) and
\(v(s_{i+1})=\T \). By the induction hypothesis, this holds if and only if \(v(s_i)=\T \) for all \(1\leq i\leq n\) and \(v(s_{n+1})=\T \) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
This gives a corollary.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-128"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">2.32</span></span>. </span> If \(s_1,\ldots , s_n\in \PF \mcal {L}\) and \(t_1,\ldots ,t_m\in \PF \mcal {L}\) are such
that \(\{s_1,\ldots ,s_n\}=\{t_1,\ldots ,t_m\}\) then
</p>

<p>
\[\bigwedge _{i=1}^ns_i\equiv \bigwedge _{i=1}^mt_i\]
</p>

<p>
and
</p>

<p>
\[\bigvee _{i=1}^ns_i\equiv \bigvee _{i=1}^mt_i\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-129"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.33</span></span>. </span> A propositional formula is in <b>disjunctive normal form (DNF)</b> if it is of the form \(\bot
\), \((\neg \bot )\) or
</p>

<p>
\[\bigvee _{i=1}^l\bigwedge _{j=1}^{m_i} g_{ij}\]
</p>

<p>
where each \(g_{ij}\) is either a propositional variable or the negation of a propositional variable.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-130"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.34</span></span><span class="amsthmnoteplain"> (The disjunctive normal form theorem)</span>. </span> If \(t\) is a
propositional formula then there exists a propositional formula \(s\) in DNF such that \(t\equiv s\). Moreover, assuming some propositional variables occur in \(t\), if \(\{p_1,\ldots ,p_n\}\) are the propositional variables occurring in \(t\)
then we can pick \(s\) of the form
</p>

<p>
\[\bigvee _{i=1}^l\bigwedge _{j=1}^{m_i} g_{ij}\]
</p>

<p>
where \(l\leq 2^n\), \(m_i\leq n+1\) and each \(g_{ij}\) is of the form \(p_k\) or \((\neg p_k)\) for \(1\leq k\leq n\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-131"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> If there are no propositional variables occurring in \(t\) then either \(t\equiv \bot \) or \(t\equiv (\neg \bot )\).
</p>

<p>
Suppose the propositional variables occurring in \(t\) are \(\{p_1,\ldots ,p_n\}\). If \(t\) is unsatisfiable then \(t\equiv (p_1\wedge (\neg p_1))\). Suppose \(t\) is not unsatisfiable. Let \(v_1,\ldots , v_l\) be the valuations on \(\PF
\mcal {L}\) where \(\PROP (\mcal {L})=\{p_1,\ldots p_n\}\) such that \(v_i(t)=\T \). For each \(i=1,\ldots ,l\) and \(j=1,\ldots , n\), define
</p>

<p>
\[g_{ij}=\left \{ \begin {array}{ll} p_j, &amp; \hbox {if $v_i(p_j)=\T $;} \\ (\neg p_j), &amp; \hbox {if $v_i(p_j)=\F $.} \end {array} \right .                                \]
</p>

<p>
<span role="note" class="marginpar">End of L7 &amp; L8</span> Let \(v\) be any valuation on \(\PF \mcal {L}\). Then \(v(\bigwedge _{j=1}^{n} g_{ij})=\T \) if and only if \(v=v_i\). Therefore \(v(\bigvee _{i=1}^l\bigwedge
_{j=1}^{n} g_{ij})=\T \) if and only if \(v=v_i\) for some \(1\leq i\leq l\). Thus \(\bigvee _{i=1}^l\bigwedge _{j=1}^{n} g_{ij}\) is of the required form and logically equivalent to \(t\). We see that \(l\leq 2^n\) because the number
of valuations on \(\PF \mcal {L}\) is \(2^n\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
This proof gives a method to find a propositional formula in DNF which is equivalent to a given formula. There is an exercise on your exercise sheet which asks you to do this in a few examples.
</p>
<!--
...... subsubsection Adequate sets of connectives ......
-->
<h6 id="autosec-132">Adequate sets of connectives</h6>
<a id="Logic-autopage-132"></a>


<p>
In this subsection we need to expand our definition of a connective. Initially, in <a href="Propositional-Logic.html#propflas">2.1</a>, they were a set of \(5\) symbols \(\{\bot , \neg , \wedge , \vee , \rightarrow \}\) each of which has an
associated number in \(\{0,1,2\}\) called the arity of the connective which determined how they could be used to form propositional formulas. At this point, apart from what they look like as symbols and what we called them, there was no real difference
between \(\wedge , \vee \) and \(\rightarrow \). In <a href="Truth.html#truth">2.2</a>, we differentiated our \(5\) connectives by defining how they behave with valuations i.e. how they behaved with respect to truth. Later in <a
href="Truth.html#truth">2.2</a>, we introduced a new connective \(\leftrightarrow \) as an abbreviation. In this section a connective will be a symbol with an arity in the set \(\{0,1,2\}\) together with rules for how it interacts with valuations. We
will usually present this final data as a truth table. For example, let \(\star \) be a connective of arity \(2\) defined by the truth table
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                1px solid black">\(s\)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(t\)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\((s\star t)\)</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\F \)</td>
</tr>

<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right:                1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right: 4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">\(\T \)</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<p>
Most of the time we will only be interested in the connectives defined in the previous subsections.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-134"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.35</span></span>. </span> Let \(\textrm {Val}_n\) be the set of valuations on the propositional language \(\mcal {L}\) with
\(\PROP (\mcal {L}):=\{p_1,\ldots ,p_n\}\). Each propositional formula \(t\) in \(\PF \mcal {L}\) defines a <b>truth function</b> \(f_t:\textrm {Val}_n\rightarrow \{\T ,\F \}\) defined by \(f_t(v):=v(t)\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-135"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.36</span></span>. </span> A set of connectives \(Y\) is <b>adequate</b> if for each \(n\in \N \) and every function
\(f:\textrm {Val}_n\rightarrow \{\T ,\F \}\) there exists a propositional formula \(t\) with propositional variables in \(\{p_1,\ldots ,p_n\}\) in which only the connectives from \(Y\) occur such that \(f=f_t\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-136"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.37</span></span>. </span> <a id="DNFadequate"></a> The set \(\{\wedge , \vee , \neg \}\) is an adequate set of
connectives.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-137"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This follows from the proof of the Disjunctive Normal Form Theorem. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-138"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">2.38</span></span>. </span> A set of connectives \(Y\) is adequate if and only if for each \(n\in \N \) and propositional formula
\(s\) with propositional variables in \(\{p_1,\ldots ,p_n\}\), there exists a propositional formula \(t\) with propositional variables in \(\{p_1,\ldots ,p_n\}\) in which only the connectives from \(Y\) occur such that \(s\equiv t\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-139"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.39</span></span>. </span> <a id="negoradequate"></a> The set of connectives \(\{\neg , \vee \}\) is adequate.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-140"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> For any propositional formulas \(s,t\), \((s\wedge t)\equiv (\neg ((\neg s)\vee (\neg t)))\). It now follows from <a
href="Truth.html#DNFadequate">2.37</a> that \(\{\neg , \vee \}\) is adequate. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-141"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.40</span></span>. </span> The set of connectives \(\{\rightarrow ,\bot \}\) is adequate.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-142"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> For any propositional formula \(s\), \((s\rightarrow \bot )\equiv (\neg s)\). For any propositional formulas \(s,t\), \((s\vee t)\equiv ((s\rightarrow
\bot )\rightarrow t)\). It now follows from <a href="Truth.html#negoradequate">2.39</a> that \(\{\rightarrow , \bot \}\) is adequate. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-143"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">2.41</span></span>. </span> The Sheffer stroke \(|\) is an arity \(2\) connective with truth table:
</p>

<p>


</p>
<table>

<tr style="display:none"><th>.</th></tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:   1px solid black">\(p\)</td>
<td class="tdc tvertbarrdouble" style="border-right:           4px double black">\(q\)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\((p | q)\)</td>
</tr>


<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:           4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(\F \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:   1px solid black">\(\T \)</td>
<td class="tdc tvertbarrdouble" style="border-right:           4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:           4px double black">\(\T \)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(\T \)</td>
</tr>


<tr>
<td class="tdc tvertbarl tvertbarr" style="border-left:           1px solid black; border-right:   1px solid black">\(\F \)</td>
<td class="tdc tvertbarrdouble" style="border-right:           4px double black">\(\F \)</td>
<td class="tdc tvertbarr" style="border-right:          1px solid black">\(\T \)</td>
</tr>


<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<p>
You will show on an exercise sheet that \(\{|\}\) is an adequate set of connectives.
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Proofs.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Proofs</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-145"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Proofs ......
-->
<h5 id="autosec-146"><span class="sectionnumber">2.3&#x2003;</span>Proofs</h5>
<a id="Logic-autopage-146"></a>
<a id="Logic-autofile-4"></a>

<p>
In the previous section we introduced the notion of logical implication. We wrote \(S\models t\) to mean if all \(s\in S\) are true then \(t\) is true. This is a semantic notion (i.e. relates to meaning). In this section we introduce formal proofs which we will
call deductions. We will use the notation \(S\proves t\) to mean \(t\) can be deduced from \(S\). After introducing our formal proof system, the main aim of the section will be to prove that if \(S\proves t\) then \(S\models t\) and that if \(S\models
t\) then \(S\proves t\). Informally, anything we can prove is true and anything that is true is provable. The first of these statements is a pretty minimal requirement for a proof system and is quite easy to prove. The second is much harder (and more
impressive).
</p>

<p>
There are many deduction systems. I have chosen Hilbert style deductions because they are the quickest to define and also allow shorter proofs of the most important theorems. However, it’s not very easy to come up with deductions in Hilbert style systems.
</p>

<p>
Before defining what a deduction is we make a modification to our propositional language. We saw in the previous section that the set \(\{\rightarrow , \bot \}\) is an adequate set of connectives. This means that a propositional language just using those
connectives is as expressive as any other propositional language. From this section onwards we will view
</p>
<ul class="itemize" style="list-style-type:none">

<li>
<p>
<span class="listmarker">•</span> \((\neg s)\) as an abbreviation for \((s\rightarrow \bot )\);
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \((s\vee t)\) as an abbreviation for \(((\neg s)\rightarrow t)\); and
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \((s\wedge t)\) as an abbreviation for \((\neg (s\rightarrow (\neg t)))\).
</p>
</li>
</ul>

<p>
The first thing we need in order to define our proof system are some axioms.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-147"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.42</span></span>. </span> The axioms of propositional logic are
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \((s\rightarrow (t\rightarrow s))\);
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(((s\rightarrow (t\rightarrow r))\rightarrow ((s\rightarrow t)\rightarrow (s\rightarrow r)))\); and
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(((\neg (\neg s))\rightarrow s)\).
</p>
</li>
</ul>

<p>
where \(s,t,r\) are any propositional formulas.
</p>

</li>

</ul>

</div>

<p>
What I’ve called axioms here are in fact axiom schemas. Each of \(1.\), \(2.\) and \(3.\) actually give infinitely many single axioms i.e. if \(p\) is a propositional variable then \(((\neg (\neg p))\rightarrow p)\) and \(((\neg (\neg (\bot
\rightarrow p)))\rightarrow (\bot \rightarrow p))\) are (different) instances of axiom \(3.\). The most important thing about these axioms is that they are all tautologies. Any set of tautologies containing this set would work just as well (although if
you take the set large enough then the results you prove become less impressive). Finally, without using abbreviations the final axiom can be written as \(((s\rightarrow (s\rightarrow \bot ))\rightarrow s)\).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-148"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.43</span></span>. </span> Let \(S\) be a set of propositional formulas. A <b>deduction</b> from \(S\) is a finite tuple
\((t_1,t_2,\ldots ,t_n)\) of propositional formulas such that for each \(1\leq k\leq n\) one of the following is true:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(t_k\) is an axiom;
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(t_k\in S\); or
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> there exist \(i,j&lt;k\) such that \(t_i\) is \((t_j\rightarrow t_k)\).
</p>
</li>
</ul>

<p>
We will call a deduction \((t_1,\ldots ,t_n)\) from \(S\) with \(t_n=t\) <b>a deduction of \(t\) from \(S\)</b> and write \(S\vdash t\) to mean there is a deduction of \(t\) from \(S\).
</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L9 &amp; L10</span>
</p>

<p>
We call \(S\) the set of <b>premisses</b> of the deduction. We call the final rule “<b>modus ponens</b>” which I will sometimes abbreviate MP.
</p>

<p>
Presenting formal deductions as tuples of propositional formulas is mathematically concise but difficult for humans to read. Moreover, it doesn’t tell us why a tuple is a deduction. To display a deduction in a way that is readable for humans we write the entries of
a deduction \((t_1,\ldots , t_n)\) as a numbered list and next to each line of the list we write the rule we are using to deduce that line i.e. is it a premise, an axiom or are we using modus ponens. Here is an example.
</p>

<p>
Let \(p,q,r\) be propositional formulas. The following tuple of propositional formulas is a deduction of \((p\rightarrow r)\) from \(\{(p\rightarrow q),(q\rightarrow r)\}\).
</p>
<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--



  ((q → r), ((q → r) → (p → (q → r))), (p → (q → r)),
                                                                                                                                                                                  ((p → (q → r)) → ((p → q) → (p → r))), ((p → q) → (p → r)), (p → q), (p → r))



-->


<p>

\begin{multline*}
((q\rightarrow r), ((q\rightarrow r)\rightarrow (p\rightarrow (q\rightarrow r))), (p\rightarrow (q\rightarrow r)), \\ ((p\rightarrow (q\rightarrow r))\rightarrow ((p\rightarrow q)\rightarrow (p\rightarrow r))),
((p\rightarrow q)\rightarrow (p\rightarrow r)), (p\rightarrow q), (p\rightarrow r))
\end{multline*}

</p>

<p>
In human readable form this is written as follows. We will refer to the comments at the side like “premiss”, “instance of axiom 1” and “modus ponens using 5. and 6. as the justification of the step.
</p>

<p>
\(\begin {array}{rcl} 1. &amp; (q\rightarrow r) &amp; \text {premiss} \\ 2. &amp; ((q\rightarrow r)\rightarrow (p\rightarrow (q\rightarrow r))) &amp; \text {instance of axiom 1.} \\ 3. &amp; (p\rightarrow
(q\rightarrow r)) &amp; \text {modus ponens using $1.$ and $2.$} \\ 4. &amp; ((p\rightarrow (q\rightarrow r))\rightarrow ((p\rightarrow q)\rightarrow (p\rightarrow r))) &amp; \text {instance of axiom 2.} \\ 5.
&amp; ((p\rightarrow q)\rightarrow (p\rightarrow r)) &amp; \text {modus ponens using $3.$ and $4.$} \\ 6. &amp; (p\rightarrow q) &amp; \text {premiss} \\ 7. &amp; (p\rightarrow r) &amp; \text {modus ponens using
$5.$ and $6.$} \end {array} \)
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-149"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2.44</span></span>. </span> <a id="simpliess"></a> For any propositional formula \(s\), \(\vdash (s\rightarrow s)\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-150"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We need to write down a formal deduction of \((s\rightarrow s)\).
</p>

<p>
\(\begin {array}{rcl} 1.       &amp; (s\rightarrow ((s\rightarrow s)\rightarrow s)) &amp; \text {instance of axiom 1.} \\ 2.           &amp; (({\color {red}\underline {\underline {s}}}\rightarrow ({\color {blue}\underline
{(s\rightarrow s)}}\rightarrow {\color {green}\uwave {s}}))\rightarrow (({\color {red}\underline {\underline {s}}}\rightarrow {\color {blue}\underline {(s\rightarrow s)}})\rightarrow ({\color {red}\underline
{\underline {s}}}\rightarrow {\color {green}\uwave {s}}))) &amp; \text {instance of axiom 2.} \\ 3.              &amp; ((s\rightarrow (s\rightarrow s))\rightarrow (s\rightarrow s)) &amp; \text {modus ponens using $1.$ and
$2.$} \\ 4.     &amp; (s\rightarrow (s\rightarrow s)) &amp; \text {instance of axiom 1.} \\ 5.          &amp; (s\rightarrow s) &amp; \text {modus ponens using $3.$ and $4.$} \end {array} \)
</p>

<p>
The colours and underlining in the deduction are there purely to highlight the propositional formulas occurring in the instance of axiom 2. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We will freely use the contents of the following remark.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-151"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.45</span></span>. </span> <a id="deductionrem"></a> The following are immediate consequences of the definition of a deduction.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> If \((t_1,\ldots ,t_n)\) is a deduction from \(S\) then so is \((t_1,\ldots , t_m)\) for all \(m\leq n\). In particular, \(S\vdash t_m\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \((t_1,\ldots , t_n)\) and \((s_1,\dots , s_m)\) are deductions from \(S\) then so is their concatenation, that is \((t_1,\ldots ,t_n,s_1,\ldots ,s_m)\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> If \(t\in S\) then \(S\vdash t\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iv)</span> If \(t\) is an instance of an axiom of propositional logic then \(\proves t\).
</p>


</li>
<li>


<p>
<span class="listmarker">(v)</span> If \(S&apos;\proves t\) and \(S&apos;\subseteq S\) then \(S\proves t\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-152"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.46</span></span><span class="amsthmnoteplain"> (“Proofs are finite”)</span>. </span> Let \(\mcal {L}\) be a propositional
language. For all \(S\subseteq \PF \mcal {L}\) and \(t\in \PF \mcal {L}\), the following are equivalent:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(S\proves t\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> There is a finite subset \(S&apos;\subseteq S\) with \(S&apos;\proves t\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-153"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Exercise - check all the details. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-154"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.47</span></span><span class="amsthmnoteplain"> (Deduction Theorem)</span>. </span> Let \(s,t\) be propositional formulas
and let \(S\) be a set of propositional formulas. Then
</p>

<p>
\[S\vdash (s\rightarrow t) \iff S\cup \{s\}\vdash t\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-155"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> \((\Rightarrow )\): If \((t_1,\ldots ,t_n)\) is a deduction of \((s\rightarrow t)\) from \(S\) then \((t_1,\ldots ,t_n,s,t)\) is a deduction of \(t\)
from \(S\cup \{s\}\). This is because if \((t_1,\ldots , t_n)\) is a deduction from \(S\) then it is also a deduction from \(S\cup \{s\}\). Therefore \((t_1,\ldots ,t_n,s)\) is a deduction from \(S\cup \{s\}\) because \(s\) is now a
premiss. Since \(t_n\) is \((s\rightarrow t)\), using modus ponens applied to \(t_n=(s\rightarrow t)\) and \(s\), we see that \((t_1,\ldots ,t_n,s,t)\) is a deduction of \(t\) from \(S\cup \{s\}\).
</p>

<p>
\((\Leftarrow )\): Let \((t_1,t_2,\ldots ,t_n)\) be a deduction from \(S\cup \{s\}\) where \(t_n=t\). We will show by induction on \(i\) that \(S\vdash (s\rightarrow t_i)\).
</p>

<p>
Suppose \(i=1\). Then \(t_1\) is either a premiss, that is, \(t_1\in S\cup \{s\}\) or \(t_1\) is an axiom. If \(t_1\) is \(s\) then <a href="Proofs.html#simpliess">2.44</a> shows that \(S\vdash (s\rightarrow t_1)\). If \(t_1\in S\) or
\(t_1\) is an axiom then the following is a deduction of \((s\rightarrow t_1)\) from \(S\).
</p>

<p>
\(\begin {array}{rcl} 1.     &amp; t_1 &amp; \text {premiss/axiom} \\ 2.        &amp; (t_1\rightarrow (s\rightarrow t_1)) &amp; \text {instance of axiom 1.} \\ 3.          &amp; (s\rightarrow t_1) &amp; \text {modus ponens using
$1.$ and $2.$} \end {array} \)
</p>

<p>
Suppose that \(S\vdash (s\rightarrow t_l)\) for all \(l&lt;i\). We want to show that \(S\vdash (s\rightarrow t_{i})\). If \(t_{i}\) is an axiom or a member of \(S\cup \{s\}\) then we can prove \(S\vdash (s\rightarrow t_{i})\) as in
the \(i=1\) case. So suppose that there are \(j,k&lt;i\) such that \(t_k\) is \((t_j\rightarrow t_{i})\). By the induction hypothesis \(S\vdash (s\rightarrow t_j)\) and \(S\vdash (s\rightarrow (t_j\rightarrow t_{i}))\). By <a
href="Proofs.html#deductionrem">2.45</a>, the concatenation of a deduction of \((s\rightarrow t_j)\) from \(S\) and a deduction of \((s\rightarrow (t_j\rightarrow t_{i}))\) from \(S\) is a deduction from \(S\). Moreover this
deduction has \((s\rightarrow t_j)\) (say entry \(n\)) and \((s\rightarrow (t_j\rightarrow t_{i}))\) (say entry \(m\)) as entries. Hence, we can then extend this deduction by adding the entries
</p>

<p>
\(\begin {array}{rcl} m+1.     &amp; ((s\rightarrow (t_j\rightarrow t_i))\rightarrow ((s\rightarrow t_j)\rightarrow (s\rightarrow t_i))) &amp; \text {instance of axiom 2.} \\ m+2.                   &amp; ((s\rightarrow t_j)\rightarrow
(s\rightarrow t_i)) &amp; \text {modus ponens with $m.$ and $m+1.$} \\ m+3.            &amp; (s\rightarrow t_i) &amp; \text {modus ponens with $n.$ and $m+2.$} \end {array} \)
</p>

<p>
Therefore we have a deduction of \((s\rightarrow t_i)\) from \(S\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Completeness.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Completeness</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-156"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Completeness ......
-->
<h5 id="autosec-157"><span class="sectionnumber">2.4&#x2003;</span>Completeness</h5>
<a id="Logic-autopage-157"></a>
<a id="Logic-autofile-5"></a>

<p>
It seems reasonable to hope that all propositional formulas that we can prove with our formal proof system are true according to our definition of truth. This property is known as soundness. Soundness together with the property that all true statements are
provable in our formal proof system is known as completeness.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-158"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.48</span></span><span class="amsthmnoteplain"> (Soundness Theorem)</span>. </span> <a id="Soundnessprop"></a> Let
\(\mcal {L}\) be a propositional language, \(S\subseteq \PF \mcal {L}\) and \(t\in \PF \mcal {L}\). If \(S\vdash t\) then \(S\models t\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-159"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose that \(S\vdash t\). Let \((t_1,\ldots , t_n)\) be a deduction from \(S\) with \(t_n=t\). We will prove by induction on \(i\) that \(S\models
t_i\).
</p>

<p>
First the base case i.e. \(i=1\). Either \(t_1\in S\) or \(t_1\) is an instance of one of the axioms of propositional logic. It follows directly from the definition of “\(\models \)” that if \(t_1\in S\) then \(S\models t_1\). We have already shown
in <a href="Truth.html#axiomsaretaut">2.21</a> that each instance of our axioms is a tautology i.e. for each instance \(r\) of the axioms of propositional logic \(\models r\). Therefore if \(t_1\) is an axiom then \(\models t_1\) and hence
\(S\models t_1\).
</p>

<p>
Now suppose that \(i&gt;1\) and that for all \(l&lt;i\), \(S\models t_l\). If \(t_i\in S\) or \(t_i\) is an axiom then proceed as in the base case. The remaining case to deal with is when there exists \(j,k&lt;i\) such that \(t_k\) is
\((t_j\rightarrow t_i)\). By our induction hypothesis \(S\models t_j\) and \(S\models (t_j\rightarrow t_i)\). Now <a href="Truth.html#modimp">2.26</a> states that \(S\models t_i\).
</p>

<p>
Therefore, by induction on \(i\), \(S\models t_i\) for all \(i\) and hence \(S\models t_n\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L11 &amp; L12</span>
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-160"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2.49</span></span>. </span> We say a set of propositional formulas \(S\) is <b>inconsistent</b> if \(S\proves \bot \) (and
<b>consistent</b> if \(S\not \vdash \bot \)).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-161"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2.50</span></span><span class="amsthmnoteplain"> (Completeness Theorem)</span>. </span> Let \(\mcal {L}\) be a
propositional language, \(S\subseteq \PF \mcal {L}\) and \(t\in \PF \mcal {L}\). Then \(S\models t\) if and only if \(S\proves t\).
</p>

</li>

</ul>

</div>

<p>
The reverse direction is the Soundness Theorem. At first glance I have no idea how to prove the forward direction of the completeness theorem. So we consider a special case, namely “\(S\models \bot \) implies \(S\vdash \bot \)”. Now the contrapositive of
this statement is “\(S\not \vdash \bot \) implies \(S\not \models \bot \)”. This says that if \(S\) is consistent then there is a valuation such that \(v(s)=\T \) for all \(s\in S\).
</p>

<p>
Before we get on with the proof of the Completeness Theorem, we record a couple of statements we will need in the proof.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-162"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">2.51</span></span>. </span> <a id="Falseproveseverything"></a> For all propositional formulas \(s,t\), we have that \(\bot
\proves t\) and \(s,(\neg s)\proves t\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-163"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> See Exercise Sheet \(4\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
It follows from <a href="Completeness.html#Falseproveseverything">2.51</a> that a set of propositional formulas \(S\subseteq \PF \mcal {L}\) is inconsistent if and only if \(S\proves t\) for all \(t\in \PF \mcal {L}\).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-164"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">2.52</span></span>. </span> <a id="adequ"></a> Let \(\mcal {L}\) be a propositional language and let \(S\subseteq \PF
\mcal {L}\). If \(S\) is consistent (i.e. \(S\not \vdash \bot \)) then there is a valuation such that \(v(s)=\T \) for all \(s\in S\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-165"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We will prove the proposition under the assumption that the set of propositional variables and hence the set of propositional formulas is countable. This is not
necessary for the statement to be true but it is necessary for this proof to work.
</p>

<p>
<b>Claim:</b> For any propositional formula \(t\), either \(S\cup \{t\}\) or \(S\cup \{(\neg t)\}\) is consistent.
</p>

<p>
Suppose that \(S\cup \{ t\}\) is inconsistent, that is \(S\cup \{t\}\vdash \bot \). By the deduction theorem, \(S\vdash (t\rightarrow \bot )\). So \(S\vdash (\neg t)\). Therefore the consistency of \(S\) implies the consistency of \(S\cup
\{(\neg t)\}\). So we have proved the claim.
</p>

<p>
Enumerate the propositional formulas as \(t_i\) for \(i\in \N \). We will define consistent sets \(S_i\) for \(i\in \N _0\) such that \(S_0:=S\) and \(S_{i+1}\supseteq S_i\) for all \(i\in \N _0\). Supposing we have already defined \(S_i\)
then let \(S_{i+1}:=S_i\cup \{t_{i+1}\}\) if this set is consistent and let \(S_{i+1}:=S_i\cup \{(\neg t_{i+1})\}\) otherwise. By the claim, \(S_{i+1}\) is consistent.
</p>

<p>
Now let \(S_*:=\bigcup _{i\in \N _0} S_i\). Suppose, for a contradiction, that \(S_*\) is not consistent. Then \(S_*\proves \bot \). But then, since proofs are finite, there is some finite subset \(S&apos;\subseteq S\) such that
\(S&apos;\proves \bot \). Since \(S&apos;\) is finite, it is contained in \(S_i\) for some \(i\). Therefore \(S_i\proves \bot \). This contradicts the fact that each \(S_i\) is consistent. Therefore \(S_*\) is consistent.
</p>

<p>
We now show that \(S_*\) is deductively closed i.e. if \(S_*\proves t\) then \(t\in S_*\). Suppose \(S_*\proves t\) and, for a contradiction, that \(t\notin S_*\). Then \((\neg t)\in S_*\). So \(S_*\proves (t\rightarrow \bot )\) and
\(S_*\proves t\). Therefore \(S_*\proves \bot \) which contradicts the fact that \(S_*\) is consistent.
</p>

<p>
Now define \(v:\PF \mcal {L}\rightarrow \{\T ,\F \}\) by setting \(v(t)=\T \) if \(t\in S_*\) and \(v(t)=\F \) otherwise. We will now show that \(v\) is a valuation.
</p>

<p>
Since we now view \(\vee ,\wedge \) and \(\neg \) as abbreviations, in order to check that \(v\) is a valuation, we just need to check the parts of the definition of a valuation for \(\bot \) and \(\rightarrow \). Since \(S_*\) is consistent, \(\bot
\notin S_*\). Therefore \(v(\bot )=\F \). To deal with \((s\rightarrow t)\), we consider \(3\) cases:
</p>

<p>
<b>Case \(v(s)=\F \):</b> In this case \(s\notin S_*\) and we want to show that \((s\rightarrow t)\in S_*\) By definition of \(S_*\), this means \((\neg s)\in S_*\). So, it is enough to show that \((s\rightarrow \bot )\proves
(s\rightarrow t)\). By the deduction theorem this is equivalent to \((s\rightarrow \bot ),s\proves t\). That this is true is part of <a href="Completeness.html#Falseproveseverything">2.51</a>.
</p>

<p>
<b>Case \(v(s)=\T \) and \(v(t)=\F \):</b> In this case \(s\in S_*\), \(t\notin S_*\) and we want to show \((s\rightarrow t)\notin S_*\). Suppose for a contradiction that \((s\rightarrow t)\in S_*\). Then, since \(s\in S_*\), the
following is a deduction of \(t\) from \(S_*\):
</p>

<p>
\(\begin {array}{rcl} 1.      &amp; (s\rightarrow t) &amp; \text {premiss} \\ 2.          &amp; s &amp; \text {premiss} \\ 3.        &amp; t &amp; \text {modus ponens using $1.$ and $2.$} \end {array} \)
</p>

<p>
But this would mean \(t\in S_*\) because \(S_*\) is deductively closed. So we have a contradiction and hence \((s\rightarrow t)\notin S_*\) as required.
</p>

<p>
<b>Case \(v(s)=\T \) and \(v(t)=\T \):</b> In this case \(s, t\in S_*\) and we want to show \((s\rightarrow t)\in S_*\). Since \((t\rightarrow (s\rightarrow t))\) is an instance of axiom 1. of propositional logic, \(S_*\proves
(t\rightarrow (s\rightarrow t))\). By the deduction theorem, since \(t\in S_*\), \(S_*\proves (s\rightarrow t)\). Since \(S_*\) is deductively closed, \((s\rightarrow t)\in S_*\) as required.
</p>

<p>
Hence we have shown that \(v\) is a valuation and \(v(s)=\T \) for all \(s\in S\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-166"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of the Completeness Theorem.</span></span> The reverse direction is the Soundness Theorem, so we prove the forward direction. Suppose that \(S\models t\). So if \(v\) is a
valuation with \(v(s)=\T \) for all \(s\in S\) then \(v(t)=\T \) and hence \(v((\neg t))=\F \). Hence \(S\cup \{(\neg t)\}\) is unsatisfiable. Therefore \(S\cup \{(\neg t)\}\models \bot \). So, by <a
href="Completeness.html#adequ">2.52</a>, \(S\cup \{(\neg t)\}\vdash \bot \). Hence, by the deduction theorem, \(S\vdash (\neg (\neg t))\). Since \(((\neg (\neg t))\rightarrow t)\) is an instance of axiom 1. of propositional logic
\(S\proves ((\neg (\neg t))\rightarrow t)\). Therefore \(S\proves t\) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Predicate-Logic.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Predicate Logic</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-167"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Predicate Logic ......
-->
<h4 id="autosec-168"><span class="sectionnumber">3&#x2003;</span>Predicate Logic</h4>
<a id="Logic-autopage-168"></a>
<a id="Logic-autofile-6"></a>
<!--
...... subsection Languages and Structures ......
-->
<h5 id="autosec-169"><span class="sectionnumber">3.1&#x2003;</span>Languages and Structures</h5>
<a id="Logic-autopage-169"></a>


<p>
We want to define a language which is rich enough to talk about most mathematical objects (or at least most of those which are sets with extra structure).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-170"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.1</span></span>. </span> A (first order) <b>language</b> consists of
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> \(3\) mutually disjoint sets: \(\mcal {R}\) the set of <b>relation symbols</b>, \(\mcal {F}\) the set of <b>function symbols</b> and \(\mcal {C}\) the set of <b>constant symbols</b>; and
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> an <b>arity function</b> \(\lambda :\mcal {R}\cup \mcal {F}\rightarrow \N \).
</p>
</li>
</ul>

<p>
For any relation symbol \(R\in \mcal {R}\) we will refer to \(\lambda (R)\) as the <b>arity</b> of \(R\) and for any function symbol \(F\) we will refer to \(\lambda (F)\) as the <b>arity</b> of \(F\).
</p>

<p>
To specify a language \(\mcal {L}\), we will sometimes write \(\mcal {L}:=\langle \mcal {R}; \mcal {F}; \mcal {C}\rangle \), \(\mcal {L}:=\langle R_1,\ldots ,R_n, F_1,\ldots F_m, c_1,\ldots , c_n\rangle \) or \(\mcal
{L}:=\langle R_1,\ldots ,R_n; F_1,\ldots F_m; c_1,\ldots , c_n\rangle \) where \(R_1,\ldots ,R_n\) is the list of relations symbols, \(F_1,\ldots F_m\) is the list of function symbols and \(c_1,\ldots , c_n\) is the list of constant
symbols of \(\mcal {L}\). If we do this then in order to fully specify the language, we still need to give the arity of each of the relation and function symbols. If we specify a language with the second notation, then we also need to say which symbols
are relation symbols, which are function symbols and which are constant symbols.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-171"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.2</span></span>. </span> Let \(\mcal {L}\) be a language. An <b>\(\mcal {L}\)-structure</b> \(\mcal {A}\) is a non-empty
set \(A\) called the <b>domain</b> (or universe or underlying set) of \(\mcal {A}\) together with
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> a subset \(R^\mcal {A}\) of \(A^{\lambda (R)}\) for each \(R\in \mcal {R}\);
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> a function \(F^\mcal {A}\) from \(A^{\lambda (F)}\rightarrow A\) for each \(F\in \mcal {F}\); and
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> an element \(c^\mcal {A}\in A\) for each \(c\in \mcal {C}\).
</p>
</li>
</ul>

<p>
We call \(R^\mcal {A}\), respectively \(F^\mcal {A}\), respectively \(c^\mcal {A}\) the <b>interpretation</b> of \(R\), respectively \(F\), respectively \(c\) in \(\mcal {A}\).
</p>

</li>

</ul>

</div>

<p>
We give some examples of languages and structures.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-172"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">3.3</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> The language of groups is \(\mcal {L}_{gp}:=\langle \cdot , (-)^{-1}, e\rangle \) where \(\cdot \) is a binary function symbol, \((-)^{-1}\) is a unary function symbol and \(e\) is a constant
symbol. Any group \(G\) gives rise to an \(\mcal {L}\)-structure \(\mcal {A}\) by interpreting \(\cdot \) as the group multiplication, \((-)^{-1}\) as the function which takes an element of the group to its inverse and \(e\) as the identity
element. However, not all \(\mcal {L}_{gp}\)-structures are groups. For instance, let \(\mcal {A}\) be the \(\mcal {L}\)-structure with domain \(\N \), \(\cdot ^{\mcal {A}}\) defined by \(a\cdot ^{\mcal {A}}b:=a+b+4\),
\(((-)^{-1})^{\mcal {A}}\) interpreted as the identity function and \(e^\mcal {A}:=7\).
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> The language of rings is \(\mcal {L}_{ring}:=\langle +,\cdot , -, 0,1\rangle \) where \(+\) and \(\cdot \) are binary function symbols, and \(0\) and \(1\) are constant symbols. Any ring gives rise
to an \(\mcal {L}_{ring}\)-structure. Again, not all \(\mcal {L}_{ring}\)-structures are rings.
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> The language of graphs is \(\mcal {L}_{graph}:=\langle E\rangle \) where \(E\) is a binary relation symbol. In this class when we say graph we mean a (possibly infinite) simple graph - this means I don’t
allow double edges or loops but I do allow infinitely many vertices (unlike in your Graph Theory and combinatorics course). A graph becomes an \(\mcal {L}_{graph}\)-structure \(\mcal {A}\) by taking the domain to be the set of vertices \(V\) and
letting \(E^{\mcal {A}}\) be the set
</p>
<p>
\[\{(a,b)\in V^2 \st \text { there is an edge between $a$ and $b$}\}.\]
</p>
<p>
Of course there are \(\mcal {L}_{graph}\)-structures which are not graphs. Exercise in class: write one down.
</p>
</li>
</ul>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Formulas.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Formulas</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-173"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Formulas ......
-->
<h5 id="autosec-174"><span class="sectionnumber">3.2&#x2003;</span>Formulas</h5>
<a id="Logic-autopage-174"></a>
<a id="Logic-autofile-7"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-175"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.4</span></span>. </span> The <b>alphabet</b> of a language \(\mcal {L}\) is the relation, functions and constant symbols of
\(\mcal {L}\) together with a set of logical symbols which are part of every language consisting of:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> Connectives: \(\{\rightarrow , \bot \}\)
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> A quantifier: \(\forall \)
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> The equality symbols \(=\)
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> Brackets \()\) and \((\)
</p>


</li>
<li>


<p>
<span class="listmarker">5.</span> Comma: ,
</p>


</li>
<li>


<p>
<span class="listmarker">6.</span> A set of variables denoted \(\textrm {Vbl}:=\{v_i \st i\in \N \}\)
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
As in propositional logic, words in an alphabet are just finite tuples from that alphabet and again, as in propositional logic, we write \(a_1a_2\ldots a_n\) rather than \((a_1,\ldots ,a_n)\).
</p>
<!--
...... subsubsection Terms and the functions they define ......
-->
<h6 id="autosec-176">Terms and the functions they define</h6>
<a id="Logic-autopage-176"></a>


<p>
We define the set of terms of \(\mcal {L}\) inductively.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-177"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.5</span></span>. </span> Let \(\mcal {L}\) be a language. Define \(\tm _0(\mcal {L})\) to be the set \(\textrm {Vbl}\cup
\mcal {C}\). For all \(k\in \N \), let
</p>

<p>
\[\tm _{k+1}(\mcal {L}):=\tm _k(\mcal {L})\cup \{F(t_1,t_2,\ldots ,t_n) \st F\in \mcal {F}, n\text { is the arity of }F \text { and } t_1,\ldots ,t_n\in \tm _{k}(\mcal {L}) \}.\]
</p>

<p>
We define the set of \(\mcal {L}\)-terms to be
</p>

<p>
\[\tm (\mcal {L}):=\bigcup _{k\in \N _0}\tm _k(\mcal {L}).\]
</p>

<p>
The complexity \(\cmpx (t)\) of an \(\mcal {L}\)-term \(t\) is the least \(k\) such that \(t\in \tm _k(\mcal {L})\).
</p>

</li>

</ul>

</div>

<p>
When a language \(\mcal {L}\) has no function symbols the set of \(\mcal {L}\)-terms is just \(\textrm {Vbl}\cup \mcal {C}\).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-178"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">3.6</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> Let \(\mcal {L}\) be the empty language i.e. the language with no relation, function or constant symbols. Then the \(\mcal {L}\)-terms are exactly the set of variables.
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> The set of \(\mcal {L}_{graph}\)-terms is exactly the set of variables.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
Every variable which occurs in a term \(t\) is called a <b>free variable</b> of \(t\) and the set of free variables of \(t\) is denoted \(\textrm {Fr}(t)\). We call those terms without free variables <b>constant terms</b>.
</p>

<p>
As we did for propositional formulas, we can draw construction trees for terms. We define them inductively.
</p>

<ul class="enumerate" style="list-style-type:none">

<li>
<p>
<span class="listmarker">(I)</span> If \(t\) is a constant symbol or a variable then the construction tree \(\text {CT}(t)\) of \(t\) is just \(t\).
</p>

</li>
<li>

<p>
<span class="listmarker">(II)</span> If \(t\) is of the form \(F(t_1,t_2,\ldots , t_n)\) for some function symbol of arity \(n\) and terms \(t_1,\ldots t_n\) then the construction tree of \(t\) is
</p>
<div class="center">
<p>

<a href="Termtreedef.png" target="_blank" ><img
    src="Termtreedef.png"
    style="
    width:130pt;
    "
    class="inlineimage"
    alt="(image)"
></a>
</p>
</div>
</li>
</ul>

<p>
Exactly as for propositional formulas, we can draw a construction tree for a term to show that it is indeed a term.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-180"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">3.7</span></span>. </span> Let \(\mcal {L}=\langle F,G,c\rangle \) where \(F\) is a function symbol of arity \(2\), \(G\) is a
function symbol of arity \(3\) and \(c\) is a constant symbol. Then \(F(G(c,v_4,v_2),F(v_1,F(c,c)))\) is and \(\mcal {L}\)-term. Here is its construction tree:
</p>
<div class="center">

<p>
<span
      id="lateximage-Logic-18"
      class="lateximagesource"
><!--
c   v4   v2   v1       F (c, c)


                   c              c
--><img
      src="Logic-images\image-18.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>
</div>

<p>
Its complexity is \(3\).
</p>

<p>
The \(\mcal {L}\)-term \(F(G(c,F(c,c),c),F(c,F(c,c)))\) is a constant term. Here is its construction tree:
</p>
<div class="center">

<p>
<span
      id="lateximage-Logic-19"
      class="lateximagesource"
><!--
c       F (c, c)       c c       F (c, c)


    c              c         c              c
--><img
    src="Logic-images\image-19.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

</li>

</ul>

</div>

<p>
In many algebraic subjects, for instance Group Theory, we use “infix” notation to denote the group operation applied to elements of the group. For instance, in \(\Z \) as a group under \(+\) we write \(5+4\) rather than \(+(5,4)\). We will do this for function
symbols in some situations (mainly when our language is meant to be the language for an algebraic structure where this is the common notation) to make our terms more easily readable.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-187"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">3.8</span></span>. </span> In this language of rings \(\mcal {L}_{ring}\), \(+(v_1,\cdot (v_1,v_2))\) is an \(\mcal
{L}_{ring}\)-term of complexity \(2\). In infix notation this is written \(v_1+(v_1\cdot v_2)\). The expression \(\cdot (v_2,v_2)\) is an \(\mcal {L}_{ring}\)-term. In infix notation it’s written \(v_2\cdot v_2\). We might even write it
\(v_2^2\) sometimes.
</p>

</li>

</ul>

</div>

<p>
Informally, this theorem says that every term has a unique construction tree. It’s proof is similar in flavour to the Unique Construction Theorem for propositional formulas. We won’t cover it.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-188"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.9</span></span><span class="amsthmnoteplain"> (Unique Construction Theorem for Terms)</span>. </span> <a
id="UniConTerms"></a> If \(t\) is an \(\mcal {L}\)-term then exactly one of the following is true:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(t\) is a variable.
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(t\) is a constant symbol.
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(t\) is of the form \(F(t_1,\ldots ,t_n)\) for a unique function symbol \(F\) of arity \(n\) and a unique \(n\)-tuple of terms \((t_1,\ldots ,t_n)\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-189"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.10</span></span>. </span> For \(n\in \N \), \(F\) a function symbol of \(\mcal {L}\) of arity \(n\) and \(t_1,\ldots ,t_n\in
\tm (\mcal {L})\),
</p>

<p>
\[\cmpx (F(t_1,\ldots ,t_n))=1+\max \{\cmpx (t_1),\ldots ,\cmpx (t_n)\}.\]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
We are now ready to discuss the functions terms define. We start with some informal examples.
</p>

<ul class="enumerate" style="list-style-type:none">

<li>
<p>
<span class="listmarker">1.</span> Let \(\mcal {L}\) be a language with a binary function symbol \(F\) and a unary function symbol \(H\). Let \(\mcal {A}\) be the \(\mcal {L}\)-structure with underlying set \(\R \), \(F^\mcal {A}(r,s)=r+7\)
and \(H^\mcal {A}(r)=r^2+1\). Let \(t\) be the \(\mcal {L}\)-term \(F(v_1,H(v_1))\). Then \(t\) defines the function from \(\R ^2\) to \(\R \) which maps \((a,b)\) to \(a+7\).
</p>

</li>
<li>

<p>
<span class="listmarker">2.</span> Let \(t\) be the \(\mcal {L}_{ring}\)-term \(+(v_1,\cdot (v_2,+(v_1,v_2)))\), written in infix notation as \(v_1+(v_2\cdot (v_1+v_2))\). If we view \(\Z \) as an \(\mcal {L}_{ring}\)-structure in the
usual way then this term defines the function from \(\Z ^2\) to \(\Z \) which maps \((a,b)\in \Z ^{2}\) to \(a+ab+b^2\).
</p>
</li>
</ul>

<p>
In some books you will see \(\mcal {L}\)-terms \(t\) having interpretations in \(\mcal {L}\)-structures \(\mcal {A}\) as functions \(t^\mcal {A}:A^n\rightarrow A\) where \(n\) is the size of a set of free variables containing the free variables of \(t\).
We choose to do something slightly different which, although slightly contrary to our natural intuition about how \(\mcal {L}\)-terms should be interpreted, will result in each \(\mcal {L}\)-term having just one interpretation rather than technically having
many.
</p>

<p>
Before making our definition we compare this with the situation of polynomials in many variables. The polynomial \(X_1^2+5X_3\) defines a function \(\R ^3\rightarrow \R \). However, perhaps I had in mind that \(X_1^2+5X_3\) was actually an element of
the polynomial ring \(\R [X_1,\ldots ,X_4]\). In this case it defines a function \(\R ^4\rightarrow \R \). So, one polynomial defines many functions. The next definition avoids this phenomena.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-190"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.11</span></span>. </span> Let \(\mcal {L}\) be a language and let \(\mcal {A}\) be an \(\mcal {L}\)-structure with domain
\(A\).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> An <b>assignment</b> of an \(\mcal {L} \)-structure \(\mcal {A} \) is a map
</p>
<p>
\[h:\textrm {Vbl} \rightarrow A .\]
</p>
<p>
Given an assignment \(h\) of \(\mcal {A}\), a variable \(x\) and an element \(a\in A\) we denote by \(h({x\atop a})\) the assignment of \(\mcal {A} \) which differs from \(h\) only at the variable \(x\), with value \(a\) at \(x\):
</p>
<p>
\[h\left ({x\atop a}\right )(y)= \begin {cases} h(y) &amp; \text {if }y\neq x \\ a &amp; \text {if }y=x.              \end {cases} \]
</p>
</li>
<li>


<p>
<span class="listmarker">(ii)</span> We define by induction on the complexity of an \(\mcal {L}\)-term \(t\) an element \(t^\mcal {A} [h]\in A\) for each assignment \(h\) of \(\mcal {A} \) as follows:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(a)</span> If \(\cmpx (t)=0\), then
</p>
<p>
\[t^\mcal {A} [h]= \begin {cases} t^\mcal {A} &amp; \text {if }t\in \mcal {C} \\ h(t) &amp; \text {if }t\in \textrm {Vbl} .                 \end {cases} \]
</p>
</li>
<li>


<p>
<span class="listmarker">(b)</span> If \(t_1,\ldots ,t_n\) are \(\mcal {L} \)-terms and \(F\in \mcal {F} \) is of arity \(n\), then we define
</p>
<p>
\[F(t_1,\ldots ,t_n)^\mcal {A} [h]:=F^\mcal {A} (t_1^\mcal {A} [h],\ldots ,t_n^\mcal {A} [h]).\]
</p>
<p>


</p>
</li>
</ul>
<p>
For each \(\mcal {L}\)-term \(t\), this definition gives a well-defined element \(t^\mcal {A}\) of \(A\) by <a href="Formulas.html#UniConTerms">3.9</a>.
</p>
</li>
</ul>

<p>
For each \(\mcal {L}\)-term \(t\), we define a function
</p>

<p>
\[t^\mcal {A}:A^\infty \rightarrow A,\]
</p>

<p>
where
</p>

<p>
\[A^\infty =\{ \bar {a} \st \bar {a}=(a_1,a_2,a_3,\ldots , a_l,\ldots ) \text { with } a_l\in A \text { for all } l\in \N \},\]
</p>

<p>
that is \(A^\infty \) is the set of all infinite sequences of elements of \(A\). So here an assignment \(h:\textrm {Vbl}\rightarrow A\) is denoted as a sequence \({\bar a}=(h(v_1),h(v_2),h(v_3),\ldots )\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-191"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.12</span></span>. </span> You will show on your exercise sheet that for \(t\) an \(\mcal {L}\)-term and \(\mcal {A}\) an
\(\mcal {L}\)-structure, \(t^\mcal {A}[h]\) only depends on the values of \(h(v_i)\) for \(v_i\in \textrm {Fr}(t)\).
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Formulas ......
-->
<h6 id="autosec-192">Formulas</h6>
<a id="Logic-autopage-192"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-193"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.13</span></span>. </span> An <b>atomic \(\mcal {L}\)-formula</b> is a word in the alphabet of \(\mcal {L}\) of the form
</p>

<p>
\[t_1=t_2\]
</p>

<p>
where \(t_1\) and \(t_2\) are \(\mcal {L}\)-terms or of the form
</p>

<p>
\[R(t_1,\ldots ,t_n)\]
</p>

<p>
where \(n\in \N \), \(t_1,\ldots ,t_n\) are \(\mcal {L}\)-terms and \(R\in \mcal {R}\) has arity \(n\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-194"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.14</span></span>. </span> We define the set of formulas \(\Fml (\mcal {L})\) of a language by induction. Let \(\Fml _0(\mcal
{L})\) be the set of all atomic \(\mcal {L}\)-formulas together with \(\bot \). For each \(k\in \N _0\), let
</p>

<p>
\[\Fml _{k+1}(\mcal {L}):=\Fml _k(\mcal {L})\cup \{(\phi \rightarrow \psi ), \st \phi ,\psi \in \Fml _k\}\cup \{ (\forall x \phi ) \st \phi \in \Fml _k\}.\]
</p>

<p>
We define the set of <b>\(\mcal {L}\)-formulas</b> to be
</p>

<p>
\[\Fml (\mcal {L}):=\bigcup _{i\in \N _0}\Fml _i(\mcal {L}).\]
</p>

<p>
The <b>complexity </b>of an \(\mcal {L}\)-formula \(\phi \) is the least \(k\in \N _0\) such that \(\phi \in \Fml _k(\mcal {L})\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-195"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.15</span></span><span class="amsthmnoteplain"> (Unique Construction for Formulas in Predicate Logic)</span>. </span>
</p>

<p>
Let \(\mcal {L}\) be a language and let \(\phi \) be an \(\mcal {L}\)-formula. Then exactly one of the following is true:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(\phi \) is \(\bot \);
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> \(\phi \) is atomic and there are uniquely determined \(t_1,t_2\in \tm (\mcal {L})\) such that \(\phi \) is \(t_1 = t_2\);
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> \(\phi \) is atomic and there are a unique \(n\in \N \), a unique relation symbol \(R\in \mcal {R}\) and uniquely determined \(\mcal {L}\)-terms \(t_1,\ldots ,t_n\) such that \(\phi \) is \(R (t_1
,\ldots ,t_n)\);
</p>


</li>
<li>


<p>
<span class="listmarker">(iv)</span> \(\phi \) is equal to \((\phi _1\rightarrow \phi _2)\) for uniquely determined \(\phi _1,\phi _2\in \Fml (\mcal {L}) \); or
</p>


</li>
<li>


<p>
<span class="listmarker">(v)</span> \(\phi \) is equal to \((\forall x \psi )\) for uniquely determined \(\psi \in \Fml (\mcal {L}) \) and \(x\in \Vbl \).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-196"></a>
<span class="amsthmnameplain">Exercise</span>. </span> Come up with a definition of the construction tree \(\textrm {CT}(\phi )\) of a formula \(\phi \) in a (first order) language \(\mcal {L}\) based on the inductive definition of an
\(\mcal {L}\)-formula. Use the following as your base case:
</p>

<p>
(I) If \(\phi \) is either an atomic formula or \(\bot \) then the construction tree of \(\phi \) is just \(\phi \).
</p>

<p>
This exercise will be on Exercise Sheet 6. For inspiration, you should look at the definition of the construction tree of a propositional formula and the definition of the construction tree of a term.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-197"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.16</span></span>. </span> <a id="freevar"></a> We define the set of free-variables \(\Fr (\phi )\) of an \(\mcal
{L}\)-formula \(\phi \) by induction.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(0)</span> \(\Fr (\bot )=\emptyset \).
</p>


</li>
<li>


<p>
<span class="listmarker">(1)</span> For all terms \(t_1,t_2\), \(\Fr (t_1=t_2)=\Fr (t_1)\cup \Fr (t_2)\) and for all terms \(t_1,\ldots ,t_n\) and relation symbols \(R\), \(\Fr (R(t_1,\ldots ,t_n))=\bigcup _{i=1}^n\Fr (t_i)\).
</p>


</li>
<li>


<p>
<span class="listmarker">(2)</span> For the inductive step, for \(\phi ,\psi \) \(\mcal {L}\)-formulas and \(x\in \Vbl \), we define
</p>
<p>
\[\Fr ((\phi \rightarrow \psi )):=\Fr (\phi )\cup \Fr (\psi )\]
</p>
<p>
and
</p>
<p>
\[\Fr ((\forall x\phi )):=\Fr (\phi )\backslash \{x\}.\]
</p>
<p>


</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
<b>Warning:</b> There will be a more complicated definition relating to free variables when we study formal proofs. <span role="note" class="marginpar">End of L19 &amp; L20</span>
</p>

<p>
<b>Abbreviations and making the language readable:</b>
</p>

<ul class="enumerate" style="list-style-type:none">

<li>
<p>
<span class="listmarker">(i)</span> In some parts of the notes, we will drop some brackets when it does not lead to ambiguity. In some places I will add brackets to increase readability.
</p>

</li>
<li>

<p>
<span class="listmarker">(ii)</span> As we did in the later part of Propositional Logic, we will view
</p>
<ul class="itemize" style="list-style-type:none">

<li>
<p>
<span class="listmarker">•</span> \((\neg \phi )\) for \(\phi \) an \(\mcal {L}\)-formula as an abbreviation for \((\phi \rightarrow \bot )\);
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \((\phi \vee \psi )\) for \(\phi ,\psi \) \(\mcal {L}\)-formulas as an abbreviation for \(((\neg \phi )\rightarrow \psi )\);
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \((\phi \wedge \psi )\) for \(\phi ,\psi \) \(\mcal {L}\)-formulas as an abbreviation for \((\neg (\phi \rightarrow (\neg \psi )))\); and
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \((\phi \leftrightarrow \psi )\) for \(\phi ,\psi \) \(\mcal {L}\)-formulas as an abbreviation for \(((\phi \rightarrow \psi )\wedge (\psi \rightarrow \phi ))\).
</p>
</li>
</ul>
</li>
<li>

<p>
<span class="listmarker">(iii)</span> You may have expected there to be a second quantifier. We will write \((\exists x \phi )\) as an abbreviation for \((\neg (\forall x(\neg \phi )))\) when \(x\in \textrm {Vbl}\) and \(\phi \) is an
\(\mcal {L}\)-formula.
</p>

</li>
<li>

<p>
<span class="listmarker">(iv)</span> If \(t,s\in \tm (\mcal {L})\) then we will write \(t\neq s\) to mean \((\neg t=s)\).
</p>

</li>
<li>

<p>
<span class="listmarker">(v)</span> We will write
</p>
<p>
\[\forall x_1,\ldots ,x_n\ \phi \text { instead of }\forall x_1...\forall x_n\phi \ldots \text { and } \exists x_1,\ldots ,x_n\ \phi \text { instead of }\exists x_1...\exists x_n\phi \]
</p>
<p>
where each \(x_i\) is a variable and \(\phi \) is a formula. Words in \(\mcal {L}\) of the form \(\forall x\) and \(\exists x\) where \(x\in \Vbl \) are called <b>quantifiers</b>.
</p>
</li>
</ul>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Tarski-Truth-Definition.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Tarski’s Truth Definition</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-198"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Tarski’s Truth Definition ......
-->
<h5 id="autosec-199"><span class="sectionnumber">3.3&#x2003;</span>Tarski’s Truth Definition</h5>
<a id="Logic-autopage-199"></a>
<a id="Logic-autofile-8"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-200"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.17</span></span><span class="amsthmnoteplain"> (Tarski’s Truth Definition)</span>. </span> Let \(\mcal {L}\) be a (first
order) language and \(\mcal {M}\) an \(\mcal {L}\)-structure with domain \(M\). We define by induction on the complexity of an \(\mcal {L} \)-formula, the expression <b>\(\phi \) is true in \(\mcal {M} \) at \(h\)</b>, denoted
</p>

<p>
\[\mcal {M} \models \phi [h],\]
</p>

<p>
for each assignment \(h:\Vbl \rightarrow M\) as follows:
</p>

<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(0)</span> \(\mcal {M}\nvDash \bot [h]\)
</p>


</li>
<li>


<p>
<span class="listmarker">(1)</span> If \(\phi \) is of the form \(t_1= t_2\) with \(\mcal {L} \)-terms \(t_1,t_2\) then
</p>
<p>
\[\mcal {M} \models t_1= t_2\ [h]\iff t^\mcal {M} _1[h]=t^\mcal {M} _2[h].\]
</p>
</li>
<li>


<p>
<span class="listmarker">(2)</span> If \(\phi \) is of the form \(R(t_1,\ldots ,t_n)\) with \(R\in \mcal {R} \) of arity \(n\) and \(t_1,\ldots ,t_n\in \tm (\mcal {L}) \) then
</p>
<p>
\[\mcal {M} \models R(t_1,\ldots ,t_n)\ [h]\iff (t^\mcal {M} _1[h],\ldots ,t^\mcal {M} _n[h])\in R^\mcal {M} .\]
</p>
</li>
<li>


<p>
<span class="listmarker">(3)</span> For the induction step we take \(\phi ,\psi \in \Fml (\mcal {L}) \), \(x\in \Vbl \) and define
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> \(\mcal {M} \models (\phi \rightarrow \psi )[h] \text { if }\mcal {M}\models \phi [h]\text { implies }\mcal {M}\models \psi [h]\),
</p>
</li>
</ul>
<p>
and
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> \(\mcal {M} \models (\forall x\phi )[h] \text { if } \text {for all }a\in M\text { we have } \mcal {M} \models \phi [h({x\atop a})].\)
</p>
</li>
</ul>
</li>
</ul>

</li>

</ul>

</div>

<p>
You will sometimes, perhaps even in these notes, see <b>\(\phi \) holds in \(\mcal {M}\) at \(h\)</b> or <b>\(\mcal {M}\) satisfies \(\phi \) at \(h\)</b>. Both these phrases mean \(\phi \) is true in \(\mcal {M}\) at \(h\).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-201"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.18</span></span><span class="amsthmnoteplain"> (Derived rules for truth)</span>. </span> Let \(\mcal {L}\) be a (first
order) language, let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\) and let \(h:\Vbl \rightarrow M\) be an assignment.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> For all \(\mcal {L}\)-formulas \(\phi \),
</p>
<p>
\[M\models (\neg \phi )[h] \text { if and only if } \mcal {M}\nvDash \phi [h].\]
</p>
</li>
<li>


<p>
<span class="listmarker">2.</span> For all \(\mcal {L}\)-formulas \(\phi ,\psi \),
</p>
<p>
\[\mcal {M}\models (\phi \wedge \psi )[h] \text { if and only if }M\models \phi [h] \text { and }M\models \psi [h]\]
</p>
<p>
and
</p>
<p>
\[\mcal {M}\models (\phi \vee \psi )[h] \text { if and only if }M\models \phi [h] \text { or }M\models \psi [h]\]
</p>
</li>
<li>


<p>
<span class="listmarker">3.</span> For all \(\mcal {L}\)-formulas \(\phi \) and \(x\in \Vbl \), \(\mcal {M}\models (\exists x\phi )[h]\) if and only if there exists \(a\in M\) such that \(\mcal {M}\models \phi [h({x\atop a})]\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-202"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> 1. and 2. will be on the next exercise sheet. We will prove \(3.\) assuming \(1.\) Recall that \((\exists x \phi )\) is an abbreviation for \((\neg (\forall
x(\neg \phi )))\). Therefore, by \(1.\), \(\mcal {M}\models (\exists x\phi )[h]\) if and only if \(\mcal {M}\vDash (\forall x(\neg \phi ))[h]\) does not hold. Now \(\mcal {M}\vDash (\forall x(\neg \phi ))[h]\) if and only if for
all \(a\in M\), \(\mcal {M}\vDash (\neg \phi )[h({x\atop a})]\). So \(\mcal {M}\vDash (\forall x(\neg \phi ))[h]\) if and only if for all \(a\in M\), \(\mcal {M}\vDash \phi [h({x\atop a})]\) does not hold. So \(\mcal {M}\vDash
(\forall x(\neg \phi ))[h]\) if and only if there exists an \(a\in M\), such that \(\mcal {M}\models \phi [h({x \atop a})]\) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We work through an example of how Tarski’s Truth Definition works.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-203"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">3.19</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\mcal {L}:=\langle F,c,d\rangle \) where \(F\) is a unary function symbol and both \(c\) and \(d\) are constant symbols. Let \(\chi \) be the \(\mcal {L}\)-formula
</p>
<p>
\[(\forall v_1(F(v_1)=c\rightarrow F(v_2)=d)).\]
</p>
<p>
Let \(\mcal {M}\) be the \(\mcal {L}\)-structure with domain \(\R \), \(F^{\mcal {M}}:\R \rightarrow \R \) defined by \(F^{\mcal {M}}(r)=r^2+1\), \(c^{\mcal {M}}:=1\) and \(d^{\mcal {M}}:=8\). We will check for which assignments
\(h:\Vbl \rightarrow \R \), we have that \(\phi \) is true in \(\mcal {M}\) at \(h\).
</p>
<p>
<b>Step 1:</b> By Tarski’s Truth Definition, \(\mcal {M}\models \chi [h]\) if and only if for all \(a\in \R \), \(\mcal {M}\models (F(v_1)=c\rightarrow F(v_2)=d)[h({v_1 \atop a})]\).
</p>
<p>
<b>Step 2:</b> By Tarski’s Truth Definition, \(\mcal {M}\models (F(v_1)=c\rightarrow F(v_2)=d)[h({v_1 \atop a})]\) if and only if \(\mcal {M}\models (F(v_1)=c)[h({v_1 \atop a})]\) implies \(\mcal {M}\models (F(v_2)=d)[h({v_1
\atop a})]\).
</p>
<p>
<b>Step 3a:</b> \(\mcal {M}\models (F(v_1)=c)[h({v_1 \atop a})]\) if and only if \(F^{\mcal {M}}(h({v_1 \atop a})(v_1))=c^{\mcal {M}}\).
</p>
<p>
Now \(h({v_1 \atop a})(v_1)=a\) by definition and \(c^{\mcal {M}}=1\). So \(\mcal {M}\models (F(v_1)=c)[h({v_1 \atop a})]\) if and only if \(a^2+1=1\).
</p>
<p>
<b>Step 3b:</b> \(\mcal {M}\models (F(v_2)=d)[h({v_1 \atop a})]\) if and only if \(F^{\mcal {M}}(h({v_1 \atop a})(v_2))=d^{\mcal {M}}\).
</p>
<p>
Now \(h({v_1 \atop a})(v_2)=h(v_2)\) and \(d^{\mcal {M}}=8\). Therefore \(F^{\mcal {M}}(h({v_1 \atop a})(v_2))=d^{\mcal {M}}\) if and only if \(h(v_2)^2+1=8\).
</p>
<p>
<b>Step 4:</b> \(\mcal {M}\models \chi [h]\) if and only if for all \(a\in \R \), \(a^2=0\) implies \(h(v_2)^2=7\).
</p>
<p>
<b>Conclusion:</b> \(\mcal {M}\models \chi [h]\) if and only if \(h(v_2)=\pm \sqrt {7}\).
</p>
</li>
<li>


<p>
<span class="listmarker">(ii)</span> Let \(\mcal {L}:=\langle R\rangle \) where \(R\) is a binary relation symbol. Let \(\chi \) be the formula
</p>
<p>
\[(\forall v_1 (\forall v_2 (R(v_1,v_2)\rightarrow R(v_2,v_1)))).\]
</p>
<p>
Let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\) and let \(h:\Vbl \rightarrow M\) be an assignment. We consider when \(\mcal {M}\models \chi [h]\).
</p>
<p>
<b>Step 1:</b> \(\mcal {M}\models \chi [h]\) if and only if for all \(a\in M\),
</p>
<p>
\[\mcal {M}\models (\forall v_2 (R(v_1,v_2)\rightarrow R(v_2,v_1)))[h({v_1\atop a})].\]
</p>
<p>
<b>Step 2:</b> \(\mcal {M}\models \chi [h]\) if and only if for all \(a\in M\) and \(b\in M\),
</p>
<p>
\[\mcal {M}\models (R(v_1,v_2)\rightarrow R(v_2,v_1))[h({v_1\atop a})({v_2 \atop b})].\]
</p>
<p>
<b>Step 3:</b> \(\mcal {M}\models \chi [h]\) if and only if for all \(a\in M\) and \(b\in M\),
</p>
<p>
\[(a,b)\in R^{\mcal {M}} \text { implies } (b,a)\in R^{\mcal {M}}.\]
</p>
<p>
<b>Conclusion:</b> \(\mcal {M}\models \chi [h]\) if and only if \(R^{\mcal {M}}\) is a symmetric relation.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L21 &amp; L22</span>
</p>

<p>
We now state some results which link truth in propositional logic with truth in predicate logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-204"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.20</span></span>. </span> Let \(\mcal {L}\) be a first order language. Let \(t\) be a propositional formula in a propositional
language with propositional variables \(p_1,\ldots ,p_n\). Let \(\phi _1,\ldots ,\phi _n\) be \(\mcal {L}\)-formulas. We define \(t(p_1/\phi _1,\ldots ,p_n/\phi _n)\) to be the \(\mcal {L}\)-formula obtained by replacing each instance
of \(p_i\) by \(\phi _i\) for \(1\leq i\leq n\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-205"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.21</span></span>. </span> We should really prove that \(t(p_1/\phi _1,\ldots ,p_n/\phi _n)\) in the above definition actually
is an \(\mcal {L}\)-formula. If you want to carry this out then prove it by induction on the complexity of \(t\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-206"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.22</span></span>. </span> <a id="proptautaretrue"></a>[Propositional tautologies are true in all structures at all
assignments]
</p>

<p>
Let \(\mcal {L}\) be a (first order) language. If \(t\) is a propositional tautology in a propositional language with propositional variables \(p_1,\ldots ,p_n\) and \(\phi _1,\ldots ,\phi _n\) are \(\mcal {L}\)-formulas then \(\mcal
{M}\models t(p_1/\phi _1,\ldots ,p_n/\phi _n)[h]\) for all \(\mcal {L}\)-structures \(\mcal {M}\) and assignments \(h\).
</p>

</li>

</ul>

</div>

<p>
This lemma is non-examinable. It implies the previous proposition and its proof if fun.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-207"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">3.23</span></span>. </span> <a id="propvalfrompred"></a> Let \(\mcal {L}\) be a (first order) language, \(\phi _1,\ldots ,\phi
_n\) \(\mcal {L}\)-formulas, \(\mcal {M}\) an \(\mcal {L}\)-structure and \(h\) an assignment of \(\mcal {M}\). Define a function \(v_h\) from the set of propositional formulas in the propositional language with propositional variables
\(p_1,\ldots ,p_n\) to the set \(\{\T ,\F \}\) by setting \(v_h(t)=\T \) if and only if \(\mcal {M}\models t(p_1/\phi _1,\ldots ,p_n/\phi _n)[h]\). Then \(v_h\) is a valuation.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-208"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The proof will be a non-compulsory exercise. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-209"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of Proposition <a href="Tarski-Truth-Definition.html#proptautaretrue">3.22</a>.</span></span> Let \(v_h\) be as in the Lemma <a
href="Tarski-Truth-Definition.html#propvalfrompred">3.23</a>. If \(t\) is a tautology then \(v_h(t)=\T \). Thus \(\mcal {M}\models t(p_1/\phi _1,\ldots ,p_n/\phi _n)[h]\) as required. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Free variables and the scope of a quantifier ......
-->
<h6 id="autosec-210">Free variables and the scope of a quantifier</h6>
<a id="Logic-autopage-210"></a>


<p>
We have a defined in <a href="Formulas.html#freevar">3.16</a> the set of free variables of a formula in a way that is best for using in most proofs. It is not the easiest definition to use in order to calculate the set of free variables or to understand what a
free variable is.
</p>

<p>
Let \(\phi :=a_1a_2\ldots a_n\) be a formula. A <b>subformula</b> of \(\phi \) is a word \(a_ia_{i+1}\ldots a_k\) such that \(i\leq k\) which is also a formula. One can prove that the subformulas of a formula are exactly those formulas which
appear in its construction tree.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-211"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.24</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> An instance of a variable \(x\) in a formula \(\phi \) is a <b>quantifier instance</b> if it appears directly after \(\forall \) or \(\exists \).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> An instance of a variable \(x\) in a formula \(\phi \) is <b>bound</b> if there is a subformula of \(\phi \) of the form \((\forall x \psi )\) (or \((\exists x \psi )\)) and this instance of \(x\)
occurs in \(\psi \). We call \(\psi \) the <b>scope</b> of the quantifier \(\forall \) (respectively \(\exists \)).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> Any instance of a variable \(x\) which is not a quantifier instance or a bound instance is a <b>free</b> instance.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
This exercise will be done during the class.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-212"></a>
<span class="amsthmnameplain">Exercise</span><span class="amsthmnumberplain"> <span class="textup">3.25</span></span>. </span> Let \(\mcal {L}_{\textrm {ring}}:=\langle 0,1,+,\cdot , -\rangle \) be the language of rings.
Label all the quantifier, free and bound instances of the variable \(v_1\) in the following \(\mcal {L}_{\textrm {ring}}\)-formula
</p>

<p>
\[(((\forall v_1(\exists v_2 (v_1\cdot v_2=1)))\vee v_1\cdot v_2=0)\rightarrow (\forall v_2 \, v_1+v_2=0))\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-213"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.26</span></span>. </span> Let \(\phi \) be a formula. The set of variables which occur as free instances in \(\phi \) is equal
to the set of free variables of \(\phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-214"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Non-examinable and not lectured. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-215"></a>
<span class="amsthmnameplain">Notation</span><span class="amsthmnumberplain"> <span class="textup">3.27</span></span>. </span> For \(\phi \) a formula, we will write \(\phi (x_1,\ldots , x_n)\) where \(x_1,\ldots ,x_n\) are
variables to indicate that the set of free variables of \(\phi \) is contained in \(\{x_1,\ldots ,x_n\}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-216"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.28</span></span>. </span> An <b>\(\mcal {L}\)-sentence</b> is a formula with no free variables i.e. \(\phi \) is a sentence
if \(\textrm {Fr}(\phi )=\emptyset \).
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Back to Tarski’s Truth Definition ......
-->
<h6 id="autosec-217">Back to Tarski’s Truth Definition</h6>
<a id="Logic-autopage-217"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-218"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.29</span></span>. </span> <a id="Onlyfrvarcount"></a> Let \(\mcal {L}\) be a language, \(\mcal {M}\) be an \(\mcal
{L}\)-structure with domain \(M\) and \(\phi \) an \(\mcal {L}\)-formula. If \(h,g:\Vbl \rightarrow M\) are assignments such that \(h(x)=g(x)\) for all \(x\in \Fr (\phi )\) then \(\mcal {M}\models \phi [h]\) if and only if \(\mcal
{M}\models \phi [g]\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-219"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We won’t include all details in some parts of the proof. On Exercise Sheet \(6\) you will show that for \(t\in \tm (\mcal {L})\), \(t^\mcal {M}[h]=t^{\mcal
{M}}[g]\) if \(g\) and \(h\) agree on the free variables of \(t\). This implies that if \(\phi \) is an atomic formula then \(\mcal {M}\models \phi [h]\) if and only if \(\mcal {M}\models \phi [g]\). Note that \(\bot \) has no free variables
and \(\mcal {M}\nvDash \bot [f]\) for all assignments \(f\). So the statement is true for all formulas of complexity \(0\). We now proceed by induction on complexity of formulas.
</p>

<p>
Suppose the statement is true for all formulas \(\psi \in \Fml _k(\mcal {L})\). Take \(\phi \in \Fml _{k+1}(\mcal {L})\backslash \Fml _k(\mcal {L})\). Then either \(\phi \) is \((\psi _1\rightarrow \psi _2)\) for some \(\psi
_1,\psi _2\in \Fml _k(\mcal {L})\) or \(\phi \) is \((\forall y\psi )\) for some \(\psi \in \Fml _k(\mcal {L})\). I leave it to you to write a proof for the case \(\phi \) is \((\psi _1\rightarrow \psi _2)\).
</p>

<p>
Suppose \(\phi \) is \((\forall y\psi )\). Then \(\Fr (\phi )=\Fr (\psi )\backslash \{y\}\). Suppose \(h(x)=g(x)\) for all \(x\in \Fr (\phi )\). Then \(\mcal {M}\models \phi [h]\) if and only if for all \(a\in M\), \(\mcal
{M}\models \psi [h({y\atop a})]\) and \(\mcal {M}\models \phi [g]\) if and only if for all \(a\in M\), \(\mcal {M}\models \psi [g({y\atop a})]\).
</p>

<p>
By assumption, \(h(x)=g(x)\) for all \(x\in \Fr (\phi )\). Therefore \(h({y\atop a})(x)=g({y\atop a})(x)\) for all \(x\in \Fr (\phi )\cup \{y\}=\Fr (\psi )\). Therefore, by our induction hypothesis, for all \(a\in M\), \(\mcal
{M}\models \psi [h({y\atop a})]\) if and only if \(\mcal {M}\models \psi [g({y\atop a})]\). Therefore \(\mcal {M}\models \phi [h]\) if and only if \(\mcal {M}\models \phi [g]\) as required. Hence, by induction on the complexity of
formulas, the statement of the proposition is true. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-220"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.30</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\phi (x_1,\ldots ,x_n)\) be an \(\mcal {L}\)-formula and \(\mcal {M}\) an \(\mcal {L}\)-structure with domain \(M\). For \(a_1,\ldots ,a_n\in M\), we write
</p>
<p>
\[\mcal {M}\models \phi [a_1,\ldots ,a_n]\]
</p>
<p>
to mean that
</p>
<p>
\[\mcal {M}\models \phi [h]\]
</p>
<p>
for some/every assignment \(h:\Vbl \rightarrow M\) such that \(h(x_i)=a_i\) for \(1\leq i\leq n\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> Let \(\phi \) be an \(\mcal {L}\)-sentence and \(\mcal {M}\) an \(\mcal {L}\)-structure. We write \(\mcal {M}\models \phi \) to mean that \(\mcal {M}\models \phi [h]\) for some/every valuation
\(h\). In this case we say <b>\(\mcal {M}\) satisfies \(\phi \)</b> or <b>\(\phi \) is true in \(\mcal {M}\)</b> or <b>\(\phi \) holds in \(\mcal {M}\)</b>. We will sometimes also say <b>\(\mcal {M}\) is a model of \(\phi
\)</b> or \(\mcal {M}\) <b>models</b> \(\phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> Let \(\Sigma \) be a set of \(\mcal {L}\)-sentences and \(\mcal {M}\) is an \(\mcal {L}\)-structure. Then we write \(\mcal {M}\models \Sigma \) to mean that for all \(\phi \in \Sigma \), \(\mcal
{M}\models \phi \). In this situation we say \(\mcal {M}\) <b>is a model of</b> \(\Sigma \) or \(\mcal {M}\) <b>satisfies</b> \(\Sigma \).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
We are finally ready to define logical implication and logical equivalence for \(\mcal {L}\)-formulas. For arbitrary formulas, the valuations of propositional logic are replaced with \(\mcal {L}\)-structures together with assignments. For (sets of) sentences,
valuations are replaced by \(\mcal {L}\)-structures.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-221"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.31</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\Sigma \subseteq \Fml (\mcal {L})\) and \(\phi \in \Fml (\mcal {L})\). We say \(\Sigma \) <b>logically implies</b> \(\phi \) and write \(\Sigma \models \phi \) if for all \(\mcal
{L}\)-structures \(\mcal {M}\) and all assignments \(h\), if \(\mcal {M}\models \psi [h]\) for all \(\psi \in \Sigma \) then \(\mcal {M}\models \phi [h]\).
</p>
<p>
As in propositional logic, we will write \(\models \phi \) to mean that \(\emptyset \models \phi \) and \(\psi _1,\ldots ,\psi _n\models \phi \) to mean \(\{\psi _1,\ldots ,\psi _n\}\models \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> We say that \(\mcal {L}\)-formulas \(\phi \) and \(\psi \) are <b>logically equivalent</b> if \(\phi \models \psi \) and \(\psi \models \phi \). In this situation we write \(\phi \equiv \psi \).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L23 &amp; L24</span>
</p>

<p>
Proposition <a href="Tarski-Truth-Definition.html#proptautaretrue">3.22</a> can now be rewritten as follows.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-222"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.32</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. If \(t\) is a propositional tautology in a propositional
language with propositional variables \(p_1,\ldots ,p_n\) and \(\phi _1,\ldots ,\phi _n\) are \(\mcal {L}\)-formulas then \(\models t(p_1/\phi _1,\ldots ,p_n/\phi _n)\). In particular, for all \(\mcal {L}\)-formulas \(\phi ,\psi \)
and \(\sigma \),
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(\models (\phi \rightarrow (\psi \rightarrow \phi ))\)
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> \(\models ((\phi \rightarrow (\psi \rightarrow \sigma ))\rightarrow ((\phi \rightarrow \psi )\rightarrow (\phi \rightarrow \sigma )))\)
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> \(\models ((\neg (\neg \phi ))\rightarrow \phi )\)
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-223"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">3.33</span></span>. </span> For all sets of \(\mcal {L}\)-formulas \(\Sigma \), \(\Sigma \models \bot \) means there is no
\(\mcal {L}\)-structure \(\mcal {M}\) and assignment \(h\) such that \(\mcal {M}\models \phi [h]\) for all \(\phi \in \Sigma \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-224"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.34</span></span>. </span> <a id="MPfortruth"></a> Let \(\phi ,\psi \) be \(\mcal {L}\)-formulas and \(\Sigma \) a set of
\(\mcal {L}\)-formulas. If \(\Sigma \models \phi \) and \(\Sigma \models (\phi \rightarrow \psi )\) then \(\Sigma \models \psi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-225"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Easy exercise! <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
So far everything we have said about logical implication is the same as for Propositional Logic. Here are some examples and non-examples involving quantifiers.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-226"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">3.35</span></span>. </span> <a id="exallandor"></a> Let \(\phi ,\psi \) be \(\mcal {L}\)-formulas and \(x\in \Vbl \).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> If \(x\notin \Fr (\phi )\) then \(\phi \equiv \forall x \, \phi \equiv \exists x \,\phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(\forall x(\phi \wedge \psi )\equiv (\forall x\phi )\wedge (\forall x\psi )\).
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \((\forall x\phi )\vee (\forall x\psi )\) logically implies \(\forall x(\phi \vee \psi )\).
</p>


</li>
<li>


<p>
<span class="listmarker">4.</span> \(\forall x(\phi \vee \psi )\) does not logically imply \((\forall x\phi )\vee (\forall x\psi )\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-227"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> 1. Let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\) and let \(h:\Vbl \rightarrow M\) be an assignment. Then \(\mcal {M}\models
\forall x\phi [h]\) if and only if for all \(a\in \mcal {M}\), \(\mcal {M}\models \phi [h({x\atop a})]\). Since \(x\notin \Fr (\phi )\), for all \(y\in \Fr (\phi )\), \(h(y)=h({x\atop a})(y)\). Therefore, by <a
href="Tarski-Truth-Definition.html#Onlyfrvarcount">3.29</a>, \(\mcal {M}\models \phi [h]\) if and only if \(\mcal {M}\models \phi [h({x\atop a})]\). Thus \(\mcal {M}\models \phi [h]\) if and only if \(\mcal {M}\models \forall
x\phi \). The proof for \(\exists \) is similar.
</p>

<p>
4. Let \(\mcal {L}:=\langle c\rangle \) where \(c\) is a constant symbol. Let \(\phi \) be \(v_1=c\) and let \(\psi \) be \(v_1\neq c\). Let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(\{0,1\}\) and \(c^{\mcal {M}}:=0\).
Let \(h:\Vbl \rightarrow \{0,1\}\) be the assignment defined by \(h(v_i)=0\) if \(i=1\) and \(h(v_i)=1\) otherwise. Then \(\mcal {M}\models \forall v_1(\phi \vee \psi )[h]\) but \(\mcal {M}\nvDash (\forall v_1 \phi )\vee
(\forall v_1 \psi )\).
</p>

<p>
I leave 2. and 3. to the reader. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-228"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.36</span></span>. </span> <a id="Axgentrueplus"></a> Let \(\phi ,\psi \) be \(\mcal {L}\)-formulas and let \(x,
x_1,\ldots , x_n\in \Vbl \).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> For all \(x\notin \Fr (\phi )\), \(\models \phi \rightarrow \forall x \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> If \(\models \phi \) then \(\models \forall x_1\ldots \forall x_n \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(\models (\forall x (\phi \rightarrow \psi ))\rightarrow ((\forall x\phi )\rightarrow (\forall x \psi ))\)
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-229"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> 1. follows from <a href="Tarski-Truth-Definition.html#exallandor">3.35</a> and <a href="Tarski-Truth-Definition.html#MPfortruth">3.34</a>. I
leave 3. as an exercise to the reader.
</p>

<p>
2. It’s enough to show that if \(\models \phi \) then \(\models \forall x \phi \). Suppose \(\models \phi \). Let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\) and let \(h\) be an assignment of \(\mcal {M}\). Then
\(\mcal {M}\models (\forall x \phi )[h]\) if and only if for all \(a\in M\), \(\mcal {M}\models \phi [h({x\atop a})]\). But this is true because \(\models \phi \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The proof of this remark will be on Exercise sheet 7.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-230"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.37</span></span>. </span> If \(x\in \Fr (\phi )\) then \(\models \phi \rightarrow \forall x \phi \) is not always true.
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Substituting terms for variables ......
-->
<h6 id="autosec-231">Substituting terms for variables</h6>
<a id="Logic-autopage-231"></a>


<p>
The words free and simultaneously are important in the next definition.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-232"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.38</span></span>. </span> Let \(\phi \in \Fml (\mcal {L})\), let \(t,t_1,\ldots ,t_n\in \tm (\mcal {L})\) and let
\(x_1,\ldots ,x_n\) be distinct variables.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> The expression \(t(x_1/t_1,\ldots ,x_n/t_n)\) denotes the word in (the alphabet of ) \(\mcal {L}\) obtained by replacing every instance of \(x_i\) in \(t\) by \(t_i\) for \(1\leq i\leq n\)
simultaneously.
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> The expression \(\phi (x_1/t_1,\ldots ,x_n/t_n)\) denotes the word in (the alphabet of ) \(\mcal {L}\) obtained by replacing every <span class="underline">free</span> instance of \(x_i\) in \(\phi
\) by \(t_i\) for \(1\leq i\leq n\) simultaneously.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-233"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.39</span></span>. </span> It can be shown by induction on the complexity of terms and induction on the complexity of formulas that
\(t(x_1/t_1,\ldots ,x_n/t_n)\) is an \(\mcal {L}\)-term and that \(\phi (x_1/t_1,\ldots ,x_n/t_n)\) is an \(\mcal {L}\)-formula.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-234"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">3.40</span></span>. </span> Let \(\mcal {L}:=\langle c\rangle \) where \(c\) is a constant symbol. Let \(\phi \) be the
\(\mcal {L}\)-formula
</p>

<p>
\[(((\forall v_1 (v_1=c\vee v_3=c))\wedge v_1=v_1)\wedge v_2=v_1).\]
</p>

<p>
Let \(t_1\) be \(v_2\) and let \(t_2\) be \(c\). Then \(\phi (v_1/t_1,v_2/t_2)\) is
</p>

<p>
\[(((\forall v_1 (v_1=c\vee v_3=c))\wedge v_2=v_2)\wedge c=v_2).\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-235"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.41</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(1)</span> A variable \(y\) is <b>substitutable for the variable \(x\) in a formula \(\phi \)</b> if the variable \(x\) does not occur as a free instance in the scope of a quantifier \(\forall y\) (or \(\exists
y\)) in \(\phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(2)</span> A term \(t\) is <b>substitutable for the variable \(x\) in a formula \(\phi \)</b> if all \(y\in \Fr (t)\) are substitutable for \(x\) in \(\phi \).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-236"></a>
<span class="amsthmnameplain">Remark</span>. </span> For any formula \(\phi \) and variable \(x\), \(x\) is substitutable for \(x\) in \(\phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-237"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">3.42</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> The variable \(v_2\) is substitutable for \(v_1\) in the formula \((v_1=v_2\wedge (\forall v_1 \exists v_2 \, v_1=v_2))\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> The variable \(v_1\) is not substitutable for \(v_2\) in the formula \(\exists v_1 \, v_1\neq v_2\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> The term \(F(v_2,v_3)\) where \(F\) is a binary function symbol is substitutable for \(v_1\) in the formula \((v_1=v_2\wedge (\forall v_1 \exists v_2 \, v_1=v_2))\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iv)</span> The term \(F(v_1,v_2)\) is not substitutable for \(v_2\) in the formula \(\exists v_1 \, v_1\neq v_2\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-238"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.43</span></span>. </span> <a id="soundnesssubax"></a> Let \(\phi \) be an \(\mcal {L}\)-formula, \(x\) a variable and
\(t\) an \(\mcal {L}\)-term. If \(t\) is substitutable for \(x\) in \(\phi \) then
</p>

<p>
\[\models (\forall x \,\phi )\rightarrow \phi (x/t).\]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L25 &amp; L26</span>
</p>

<p>
<b>Warning:</b> The condition “\(t\) is substitutable for \(x\) in \(\phi \)” is necessary. For example, if \(\phi \) is \((\exists v_1\, v_1\neq v_2)\) and \(t\) is \(v_1\) then \(\nvDash (\forall v_2 \,\phi )\rightarrow \phi (v_2/v_1)\).
Checking the details is on Exercise Sheet 7.
</p>

<p>
In order to prove this proposition we need to make some observations and prove a lemma.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-239"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.44</span></span>. </span> <a id="subrem"></a> Let \(\phi , \psi ,\psi _1,\psi _2\) be formulas, \(t\) a term and \(x,y,z\)
variables.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(I)</span> Suppose \(\phi \) is \((\psi _1\rightarrow \psi _2)\). Then \(t\) is substitutable for \(x\) in \(\phi \) if and only if \(t\) is substitutable for \(x\) in \(\psi _1\) and in \(\psi _2\).
</p>


</li>
<li>


<p>
<span class="listmarker">(II)</span> Suppose \(\phi \) is \((\forall z \,\psi )\).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(a)</span> Then \(y\) is substitutable for \(x\) in \(\phi \) if and only if
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> \(x\notin \Fr (\phi )\); or
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> \(z\neq y\) and \(y\) is substitutable for \(x\) in \(\psi \).
</p>
</li>
</ul>
</li>
<li>


<p>
<span class="listmarker">(b)</span> Then \(t\) is substitutable for \(x\) in \(\phi \) if and only if
</p>
<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> \(x\notin \Fr (\phi )\); or
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> \(z\notin \Fr (t)\) and \(t\) is substitutable for \(x\) in \(\psi \).
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-240"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (II) is the tricky statement and (II)(b) is an easy consequence of (II)(a). So we prove (II)(a).
</p>

<p>
We first prove the forward direction. Suppose \(y\) is substitutable for \(x\) in \(\phi \) and \(x\in \Fr (\phi )\). Then \(z\neq x\) and \(x\in \Fr (\psi )\). Since \(y\) is substitutable for \(x\) in \(\phi \) and \(x\in \Fr (\psi )\),
\(y\neq z\). Suppose \(y\) is not substitutable for \(x\) in \(\psi \). Then a free instance of \(x\) occurs in the scope of \(\forall y\) in \(\psi \). Since \(z\neq x\), that instance stays free in \(\phi \).
</p>

<p>
We now prove the reverse direction. If \(x\notin \Fr (\phi )\) then trivially \(y\) is substitutable for \(x\). So suppose \(z\neq y\) and \(y\) is substitutable for \(x\) in \(\psi \). Then no free instance of \(x\) occurs in the scope of a
quantifier \(\forall y\) in \(\psi \) and since \(z\neq y\) this is also true for \(\phi \). Therefore \(y\) is substitutable for \(x\) in \(\phi \) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-241"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">3.45</span></span>. </span> <a id="sublemma"></a> Let \(\phi \) be a formula, \(x\) a variable and \(t\) a term. If \(t\) is
substitutable for \(x\) then for all \(\mcal {L}\)-structures \(\mcal {M}\) and assignments \(h\) of \(\mcal {M}\),
</p>

<p>
\[\mcal {M}\models \phi (x/t)[h] \text { if and only if } \mcal {M}\models \phi [h\left ({x\atop t^{\mcal {M}}[h]}\right )].\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-242"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The case when \(\phi \) is an atomic formula is on exercise sheet \(7\).
</p>

<p>
Suppose the statement is true for all \(\psi \in \Fml _k(\mcal {L})\). Take \(\phi \in \Fml _{k+1}(\mcal {L})\). Then \(\phi \) is either of the form \((\psi _1\rightarrow \psi _2)\) for \(\psi _1,\psi _2\in \Fml _k(\mcal {L})\) or
\(\phi \) is \(\forall z\psi \) for \(\psi \in \Fml _k(\mcal {L})\) and \(z\in \Vbl \). I leave the case where \(\phi \) is \((\psi _1\rightarrow \psi _2)\) to the reader.
</p>

<p>
Suppose \(\phi \) is \(\forall z\,\psi \) for \(\psi \in \Fml _k(\mcal {L})\) and \(z\in \Vbl \). By \(\ref {subrem}\), since \(t\) is substitutable for \(x\) in \(\phi \), either \(x\notin \Fr (\phi )\), or, \(z\notin \Fr (t)\) and
\(t\) is substitutable for \(x\) in \(\psi \). In the first case, \(\phi (x/t)\) is \(\phi \) and \(\mcal {M}\models \phi [h]\) if and only if \(\mcal {M}\models \phi [h({x\atop a})]\) for any \(a\in M\) because \(x\notin \Fr (\phi )\). So
we just need to consider the second case. Suppose \(z\notin \Fr (t)\) and \(t\) is substitutable for \(x\) in \(\psi \). We split further into \(2\) cases. First suppose that \(x=z\). Then \((\forall z\psi )(x/t)\) is \(\forall x\psi \). Thus
the statement of the lemma holds because \(x\notin \Fr (\forall x\psi )\). Now suppose that \(x\neq z\). Then \(\phi (x/t)\) is \(\forall z \psi (x/t)\). So \(\mcal {M}\models \phi (x/t)[h]\) if and only if \(\mcal {M}\models
\psi (x/t)[h({z\atop a})]\) for all \(a\in M\). By the induction hypothesis, this is true if and only if \(\mcal {M}\models \psi [h({z\atop a})({x\atop t^{\mcal {M}}})]\). Since \(x\neq z\), this is true if and only if \(\mcal {M}\models
\phi [h({x\atop a})]\) as required. The lemma now follows by induction on the complexity of formulas. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The work to prove <a href="Tarski-Truth-Definition.html#soundnesssubax">3.43</a> is mostly in the proof of the previous lemma.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-243"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of Proposition <a href="Tarski-Truth-Definition.html#soundnesssubax">3.43</a>.</span></span> We suppose that \(\phi , t\) and \(x\) are as in the statement of the
proposition. Let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\) and let \(h\) be an assignment of \(\mcal {M}\). We need to show \(\mcal {M}\models ((\forall x \phi )\rightarrow \phi (x/t)) [h]\). According to Tarski’s
Truth Definition, we need to show that if \(\mcal {M}\models (\forall x \phi )[h]\) then \(\mcal {M}\models \phi (x/t)[h]\). Suppose \(\mcal {M}\models (\forall x \phi )[h]\). Then for all \(a\in M\), \(\mcal {M}\models \phi
[h({x\atop a})]\). So, in particular, \(\mcal {M}\models \phi [h\left ({x\atop t^{\mcal {M}}[h]}\right )].\) By <a href="Tarski-Truth-Definition.html#sublemma">3.45</a> and since \(t\) is substitutable for \(x\) in \(\phi \), this
is equivalent to \(\mcal {M}\models \phi (x/t)[h]\) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Proofs-9.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Proofs</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-244"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Proofs ......
-->
<h5 id="autosec-245"><span class="sectionnumber">3.4&#x2003;</span>Proofs</h5>
<a id="Logic-autopage-245"></a>
<a id="Logic-autofile-9"></a>

<p>
I have deliberately chosen a Hilbert style proof system which is as similar as possible to the one we used for Propositional Logic. Like in Propositional Logic we will have a number of axioms and one deduction rule (modus ponens). If you look in books, even
amongst those that use a Hilbert style proof system, you will see a lot of variance particularly amongst what formulas are chosen to be axioms. One fairly unusual choice I have made is to have only one deduction rule whereas many other sources also have a
“generalisation rule”. I have removed the need for this by adding extra axioms.
</p>

<p>
Our first task for this section is to define what a deduction is for predicate logic and hence to define the symbol \(\proves \).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-246"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.46</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. Each of the following \(\mcal {L}\)-formulas are called
<b>logical axioms</b> (of \(\mcal {L} \)), where \(\phi ,\psi \) and \(\gamma \) are \(\mcal {L} \)-formulas and \(x\) is a variable:
</p>

<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><b>(AxProp)</b></span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(a)</span> \(\phi \to (\psi \to \phi )\)
</p>


</li>
<li>


<p>
<span class="listmarker">(b)</span> \((\phi \to (\psi \to \gamma )) \to ((\phi \to \psi ) \to (\phi \to \gamma ))\)
</p>


</li>
<li>


<p>
<span class="listmarker">(c)</span> \(((\lnot \psi )\to (\lnot \phi )) \to ( \phi \to \psi )\)
</p>
</li>
</ul>
</li>
<li>


<p>
<span class="listmarker"><b>(Ax\(\forall \!\rightarrow \))</b></span> \(\forall x(\phi \rightarrow \psi )\ \rightarrow \ ((\forall x \phi ) \ \rightarrow \ (\forall x\psi ))\)
</p>


</li>
<li>


<p>
<span class="listmarker"><b>(AxSub)</b></span> \((\forall x\phi )\ \rightarrow \ \phi (x/t)\), where \(t\in \tm (\mcal {L})\) is substitutable in \(\phi \) for \(x\)
</p>
</li>
<li>


<p>
<span class="listmarker"><b>(AxGen)</b></span> \(\phi \rightarrow \forall x\phi \), where \(x\) is <i>not</i> a free variable of \(\phi \)
</p>
</li>
<li>


<p>
<span class="listmarker"><b>(Ax x=x)</b></span> \(x=x\)
</p>


</li>
<li>


<p>
<span class="listmarker"><b>(AxEq)</b> </span> \(x=y\rightarrow (\phi \rightarrow \phi (x/y))\) where \(y\) is substitutable for \(x\) in \(\phi \).
</p>


</li>
<li>


<p>
<span class="listmarker"><b>(Ax\(\forall \))</b>              </span> Any formula of the form
</p>
<p>
\[\forall x_1\,\ldots \,\forall x_n\ \alpha \]
</p>
<p>
where \(\alpha \) is one of the formulas introduced by the other logical axioms above and \(x_1,...,x_n\) are variables.
</p>
</li>
</ul>

<p>
We call <b>(AxSub)</b> the substitution axiom, <b>(AxEq)</b> the axiom of equality and <b>(AxGen)</b> the generalisation axiom.
</p>

</li>

</ul>

</div>

<p>
I will also refer to these \(\mcal {L}\)-formulas as the axioms for predicate logic. This is a tiny bit dodgy because the axioms are actually different depending on \(\mcal {L}\) because the formulas involved are \(\mcal {L}\)-formulas.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-247"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.47</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas. A
<b>deduction</b> from \(\Sigma \) is a finite tuple \((\phi _1,\phi _2,\ldots ,\phi _n)\) of \(\mcal {L}\)-formulas such that for each \(1\leq k\leq n\) one of the following is true:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(\phi _k\) is a logical axiom (of \(\mcal {L}\));
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(\phi _k\in \Sigma \); or
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> there exist \(i,j&lt;k\) such that \(\phi _i\) is \((\phi _j\rightarrow \phi _k)\).
</p>
</li>
</ul>

<p>
We will call a deduction \((\phi _1,\ldots ,\phi _n)\) from \(\Sigma \) with \(\phi _n=\phi \) <b>a deduction of \(\phi \) from \(\Sigma \)</b> and write \(\Sigma \vdash \phi \) to mean there is a deduction of \(\phi \) from
\(\Sigma \).
</p>

</li>

</ul>

</div>

<p>
Note that I copied and pasted this definition from the propositional logic section, swapped “axiom” for logical axiom (of \(\mcal {L}\)), swapped \(t\) for \(\phi \) and \(S\) for \(\Sigma \). We will call the final rule “<b>modus ponens</b>” and sometimes
abbreviate it MP. Exactly as in propositional logic, I will display deductions as a series of numbered lines with a justification of each line on the right hand side. Finally, I will some times say \(\Sigma \) proves \(\phi \) to mean \(\Sigma \proves \phi \).
</p>

<p>
We get the same immediate consequences of the definition of a deduction as we did for propositional logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-248"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.48</span></span>. </span> <a id="deductionrempred"></a> The following are immediate consequences of the definition of a
deduction.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> If \((\phi _1,\ldots ,\phi _n)\) is a deduction from \(\Sigma \) then so is \((\phi _1,\ldots , \phi _m)\) for all \(m\leq n\). In particular, \(\Sigma \vdash \phi _m\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \((\phi _1,\ldots , \phi _n)\) and \((\psi _1,\dots , \psi _m)\) are deductions from \(\Sigma \) then so is their concatenation, that is \((\phi _1,\ldots ,\phi _n,\psi _1,\ldots ,\psi
_m)\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> If \(\phi \in \Sigma \) then \(\Sigma \vdash \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(iv)</span> If \(\phi \) is an instance of a logic axiom (of \(\mcal {L}\)) then \(\proves \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(v)</span> If \(\Sigma &apos;\proves \phi \) and \(\Sigma &apos;\subseteq \Sigma \) then \(\Sigma \proves \phi \).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
I didn’t include the next statement in the propositional logic section but the appropriate version does also hold for propositional logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-249"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.49</span></span><span class="amsthmnoteplain"> (Modus Ponens for proofs)</span>. </span> If \(\Sigma \proves \phi
\rightarrow \psi \) and \(\Sigma \proves \phi \) then \(\Sigma \proves \psi \).
</p>

</li>

</ul>

</div>

<p>
We also get a “Proofs are finite” Theorem for Predicate Logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-250"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.50</span></span><span class="amsthmnoteplain"> (“Proofs are finite”)</span>. </span> Let \(\mcal {L}\) be a (first order)
language. For all \(\Sigma \subseteq \Fml (\mcal {L})\) and \(\phi \in \Fml (\mcal {L})\), the following are equivalent:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(\Sigma \proves \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> There is a finite subset \(\Sigma &apos;\subseteq \Sigma \) with \(\Sigma &apos;\proves \phi \).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-251"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The audience should tell me how to prove this. It is the same for Propositional Logic where it was an exercise. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-252"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.51</span></span>. </span> Replacing propositional variables by \(\mcal {L}\)-formulas in a deduction in propositional logic gives us
a deduction in predicate logic. For instance, we show that \(\vdash (s\rightarrow s)\) for \(s\) a propositional formula. Replacing every instance of \(s\) in the deduction by a formula \(\phi \) in a (first order) language \(\mcal {L}\) give us
a deduction in predicate logic and this shows that \(\vdash (\phi \rightarrow \phi )\)
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-253"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.52</span></span><span class="amsthmnoteplain"> (Deduction Theorem)</span>. </span> Let \(\phi ,\psi \) be \(\mcal
{L}\)-formulas and let \(\Sigma \) be a set of \(\mcal {L}\)-formulas. Then
</p>

<p>
\[\Sigma \proves (\phi \rightarrow \psi ) \text { if and only if }\Sigma \cup \{\phi \}\proves \psi .\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-254"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Exercise: Check that the proof for propositional logic works for predicate logic (with cosmetic changes). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The next theorem is usually included as an extra deduction rule but since we have done that, we need to prove it.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-255"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.53</span></span><span class="amsthmnoteplain"> (Generalisation Theorem)</span>. </span> Let \(\Sigma \) be a set of
\(\mcal {L}\)-formulas and let \(\phi \) be an \(\mcal {L}\)-formula. If \(x\in \Vbl \) does not occur as a free instance in any formula in \(\Sigma \) then
</p>

<p>
\[\Sigma \proves \phi \text { if and only if } \Sigma \proves \forall x \, \phi .\]
</p>

<p>
<b>Note:</b> There may well be a free instance of \(x\) occurring in \(\phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-256"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The reverse direction holds even without the assumption that \(x\) does not occur freely in any formula from \(\Sigma \) by <b>(AxSub)</b> applied with
\(x=t\) and Modus Ponens for proofs.
</p>

<p>
The more difficult and important direction is the forwards direction, i.e., \(\Sigma \proves \phi \) implies \(\Sigma \proves \forall x \, \phi \).
</p>

<p>
Suppose that the variable \(x\) does not occur as a free instance in any formula in \(\Sigma \) and that \((\phi _1,\ldots , \phi _n)\) is a deduction. We will prove that \(\Sigma \proves \forall x \, \phi \) by induction on the length of
the deduction.
</p>

<p>
If \(\phi \) is a logical axiom then, by <b>(Ax\(\forall \))</b>, \(\forall x\phi \) is a logical axiom and thus \(\Sigma \vdash \forall x\phi \). If \(\phi \in \Sigma \), then by assumption, \(x\) does not occur freely in \(\phi \).
Hence, by <b>(AxGen)</b>, \(\phi \rightarrow \forall x\phi \) is a logical axiom. Applying Modus Ponens for proofs we get \(\Sigma \vdash \forall x\phi \).
</p>

<p>
For the induction step, suppose \((\phi _1,...,\phi _{n+1})\) is a proof from \(\Sigma \) with \(\phi =\phi _{n+1}\). From what we have seen above we may assume that \(\phi \) is neither a logical axiom nor an element of \(\Sigma \).
Hence there are \(i,j\leq n\) such that \(\phi _j\) is \(\phi _i\rightarrow \phi _{n+1}\).
</p>

<p>
By (Ax\(\forall \!\rightarrow \)) we have that
</p>

<p>
\[\forall x(\phi _i\rightarrow \phi _{n+1})\ \rightarrow \ (\forall x \phi _i\ \rightarrow \ \forall x\phi _{n+1})\]
</p>

<p>
is a logical axiom. By the induction hypothesis we know \(\Sigma \vdash \forall x\phi _j\), in other words \(\Sigma \vdash \forall x(\phi _i\rightarrow \phi _{n+1})\). So by Modus Ponens for proofs we get \(\Sigma \vdash \forall
x \phi _i\ \rightarrow \ \forall x\phi _{n+1}\). Since also \(\Sigma \vdash \forall x \phi _i\) by induction we may apply Modus Ponens for proofs again to obtain \(\Sigma \vdash \forall x\phi _{n+1}\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Completeness-10.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Completeness</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-257"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Completeness ......
-->
<h5 id="autosec-258"><span class="sectionnumber">3.5&#x2003;</span>Completeness</h5>
<a id="Logic-autopage-258"></a>
<a id="Logic-autofile-10"></a>

<p>
Using propositional logic as a guide, we first prove the soundness theorem for predicate logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-259"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.54</span></span><span class="amsthmnoteplain"> (Soundness Theorem)</span>. </span> Let \(\mcal {L}\) be a (first order)
language, \(\Sigma \subseteq \Fml (\mcal {L})\) and \(\phi \in \Fml (\mcal {L})\). If \(\Sigma \proves \phi \) then \(\Sigma \models \phi \).
</p>

</li>

</ul>

</div>

<p>
The proof goes as in propositional logic (because our only deduction rule is modus ponens). We need to input the fact that for all logical axioms \(\phi \), we have \(\models \phi \). This is more work than in propositional logic because our axioms are more
complicated and more numerous.
</p>

<p>
We have already done some work towards the proof of the next lemma and some of the remaining parts will be on your exercise sheet.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-260"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">3.55</span></span>. </span> <a id="SoundAxPred"></a> Let \(\mcal {L}\) be a (first order) language. For all logical axioms \(\phi
\) (of \(\mcal {L}\)), \(\models \phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-261"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> If \(\phi \) is an instance of one of the axioms <b>(AxProp)</b> then \(\models \phi \) by <a
href="Tarski-Truth-Definition.html#proptautaretrue">3.22</a>. If \(\phi \) is an instance of <b>(AxGen)</b> then \(\models \phi \) by <a href="Tarski-Truth-Definition.html#Axgentrueplus">3.36</a>. If \(\phi \) is an instance of
<b>(AxSub)</b> then \(\models \phi \) by <a href="Tarski-Truth-Definition.html#soundnesssubax">3.43</a>. The work towards proving \(\models \phi \) where \(\phi \) is an instance of <b>(AxEq)</b> is started on Exercise Sheet
\(7\) in Exercises \(3\) and \(4\). There will be more on Exercise Sheet \(8\) (I will include the full details after Exercise Sheet \(8\) has been released). The proof that \(\models \phi \) when \(\phi \) is an instance of <b>(Ax\(\forall
\rightarrow \))</b> will be on Exercise Sheet \(8\) - this is a relatively straightforward exercise.
</p>

<p>
It remains to show that \(\models \phi \) when \(\phi \) is an instance of <b>(Ax\(\forall \))</b>. If \(\phi \) is an instance of <b>(Ax\(\forall \))</b> then it is of the form \(\forall x_1\ldots \forall x_n \,\psi \) where \(\psi
\) is an instance of one of the other logical axioms. We have shown (or at least, in some cases, you will show on your exercise sheets) that for all \(\mcal {L}\)-structures \(\mcal {M}\) with domain \(M\) and assignments \(h:\Vbl \rightarrow
M\), \(\mcal {M}\models \psi [h]\). For any variable \(x\), Tarski’s Truth Definition says that \(\mcal {M}\models (\forall x \psi )\) if and only if for all \(a\in M\), \(\mcal {M}\models \psi [h({x\atop a})]\). Since \(h({x\atop a})\)
is also an assignment, this is true. To prove \(\mcal {M}\models \phi [h]\) we just iterate this proof. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We now prove the Soundness Theorem.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-262"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of the Soundness Theorem.</span></span> The proof is exactly as for the Soundness Theorem for Propositional Logic (<a href="Completeness.html#Soundnessprop">2.48</a>)
except we replace <a href="Truth.html#axiomsaretaut">2.21</a> with <a href="Completeness-10.html#SoundAxPred">3.55</a> and <a href="Truth.html#modimp">2.26</a> with <a
href="Tarski-Truth-Definition.html#MPfortruth">3.34</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L27 &amp; L28</span>
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-263"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.56</span></span>. </span> We say that a set of \(\mcal {L}\)-sentences \(\Sigma \) is <b>consistent</b> if \(\Sigma \nvdash
\bot \) and <b>inconsistent</b> if \(\Sigma \vdash \bot \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-264"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.57</span></span>. </span> We say that a set of \(\mcal {L}\)-sentences \(\Sigma \) is <b>satisfiable</b> if \(\Sigma \nvDash
\bot \) and <b>unsatisfiable</b> if \(\Sigma \vDash \bot \).
</p>

</li>

</ul>

</div>

<p>
The Soundness Theorem has a useful corollary. We will essentially never prove that a set of \(\mcal {L}\)-sentences is consistent syntactically. Instead, we will always use the Soundness Theorem.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-265"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.58</span></span>. </span> If \(\Sigma \) a set of \(\mcal {L}\)-sentences is satisfiable, that is, has a model, then \(\Sigma \) is
consistent.
</p>

</li>

</ul>

</div>

<p>
The following theorem is called Go&#x0308;del’s Completeness Theorem. I will also refer to it as the Completeness Theorem for Predicate Logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-266"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.59</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas and
let \(\phi \) be an \(\mcal {L}\)-formula. Then \(\Sigma \models \phi \) if and only if \(\Sigma \proves \phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-267"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The proof of this theorem is only examinable for 4th years. The proof is in section \(4\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-268"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.60</span></span>. </span> If \(\Sigma \) a set of \(\mcal {L}\)-sentences is consistent then \(\Sigma \) is satisfiable.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-269"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.61</span></span><span class="amsthmnoteplain"> (The Compactness Theorem)</span>. </span> Let \(\mcal {L}\) be a (first
order) language and let \(\Sigma \) be a set of \(\mcal {L}\)-sentences. If every finite subset of \(\Sigma \) is satisfiable then \(\Sigma \) is satisfiable.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-270"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We prove the contrapositive of the theorem. That is, we show that if a set of \(\mcal {L}\)-sentences \(\Sigma \) does not have a model then there is some
finite subset \(\Sigma _0\) of \(\Sigma \) which does not have a model. The Completeness Theorem states that if \(\Delta \) is a set of \(\mcal {L}\)-formulas and \(\phi \) is an \(\mcal {L}\)-formula then \(\Delta \vdash \phi \) if and
only if \(\Delta \vDash \phi \). Suppose \(\Sigma \) does not have a model. Then \(\Sigma \vDash \bot \). Therefore \(\Sigma \vdash \bot \). Since “Proofs are finite”, there is a subset \(\Sigma _0\) of \(\Sigma \) such that \(\Sigma
_0\vdash \bot \). By the Completeness Theorem, \(\Sigma _0\models \bot \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The next \(3\)rd year section is <a href="Application-Compactness-Theorem-Extension-Constants.html#appcomp">5</a>.
</p>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Proof of the Completeness Theorem for Predicate Logic (4th year material)</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-271"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Proof of the Completeness Theorem for Predicate Logic (4th year material) ......
-->
<h4 id="autosec-272"><span class="sectionnumber">4&#x2003;</span>Proof of the Completeness Theorem for Predicate Logic (4th year material)</h4>
<a id="Logic-autopage-272"></a>
<a id="Logic-autofile-11"></a>

<p>
The content of this section is one of the advanced topics. We will refer forward to material in the next section at least once. The aim of this section is to prove the Model Existence Theorem and to deduce from it Go&#x0308;del’s Completeness Theorem.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-273"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">4.1</span></span><span class="amsthmnoteplain"> (Model Existence Theorem)</span>. </span> <a id="ModelExThm"></a> Let
\(\mcal {L}\) be a (first order) language. If \(\Sigma \) is a consistent set of \(\mcal {L}\)-sentences then \(\Sigma \) has a model.
</p>

</li>

</ul>

</div>

<p>
Although this theorem is true without any assumption on \(\mcal {L}\), to avoid using Zorn’s Lemma, we will prove it only for the case when \(\mcal {L}\) and hence \(\Fml (\mcal {L})\) are countable. I will make it clear exactly when I am using
countability of \(\mcal {L}\).
</p>

<p>
The first thing we need is a tool for constructing \(\mcal {L}\)-structures out of sentences. What we will do is a bit more general than what we actually need for the proof of the Model Existence Theorem. The \(\mcal {L}\)-structures we will construct are
called term algebras. They are built out of the constant terms of \(\mcal {L}\). If our language has no constant symbols then it has no constant terms. So we work under the assumption that our language has at least one constant symbol. This might seem a
bit strange at this point but by the time we actually get to using them we will have extended our original language to a language with lots of constants - so it won’t cause any harm.
</p>
<!--
...... subsubsection Term Algebras ......
-->
<h6 id="autosec-274">Term Algebras</h6>
<a id="Logic-autopage-274"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-275"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.2</span></span>. </span> Let \(\mcal {L}\) be a language and \(\Sigma \subseteq \Fml (\mcal {L})\).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\ctm (\mcal {L})\) denote the set of constant terms of \(\mcal {L}\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> Define the relation \(\sim _\Sigma \) on \(\ctm (\mcal {L})\) by \(t_1\sim _\Sigma t_2\) for \(t_1,t_2\in \ctm (\mcal {L})\) if \(\Sigma \proves t_1=t_2\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-276"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.3</span></span>. </span> Let \(\Sigma \subseteq \Fml (\mcal {L})\) and let \(t_1,s_1,\ldots ,t_n,s_n\in \ctm (\mcal
{L})\).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(\sim _\Sigma \) is an equivalence relation.
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \(F\) is a function symbol of \(\mcal {L}\) of arity \(n\) such that \(t_i\sim _\Sigma s_i\) for each \(1\leq i\leq n\) then \(F(t_1,\ldots ,t_n)\sim _\Sigma F(s_1,\ldots ,s_n)\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> If \(R\) is a relation symbol of \(\mcal {L}\) of arity \(n\) such that \(t_i\sim _\Sigma s_i\) for each \(1\leq i\leq n\) then \(\Sigma \vdash R(t_1,\ldots ,t_n)\leftrightarrow R(s_1,\ldots
,s_n)\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-277"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (i) Let \(t\in \ctm (\mcal {L})\). By <b>(Ax x=x)</b> and <b>(Ax\(\forall \))</b>,\(\proves v_1=v_1\) and \(\proves \forall v_1\, v_1=v_1\).
Thus, by <b>(AxSub)</b> and modus ponens, \(\proves t=t\). So \(\sim _\Sigma \) is reflexive.
</p>

<p>
From Exercise Sheet 8, we know that for all variables \(x,y,z\)
</p>

<p>
\[\vdash \forall x,y (x=y\rightarrow y=x)\]
</p>

<p>
and
</p>

<p>
\[\vdash \forall x,y,z (x=y\rightarrow (y=z\rightarrow x=z)).\]
</p>

<p>
Suppose \(t_1\sim _\Sigma t_2\). Then \(\Sigma \vdash t_1=t_2\). By <b>(AxSub)</b> and modus ponens,
</p>

<p>
\[\Sigma \proves t_2=t_1.\]
</p>

<p>
So \(\sim _\Sigma \) is symmetric.
</p>

<p>
Suppose \(t_1\sim _\Sigma t_2\) and \(t_2\sim _\Sigma t_3\). Then \(\Sigma \vdash t_1=t_2\) and \(\Sigma \vdash t_2=t_3\). By <b>(AxSub)</b>,
</p>

<p>
\[\Sigma \proves (t_1=t_2\rightarrow (t_2=t_3\rightarrow t_1=t_3)).\]
</p>

<p>
By modus ponens applied twice,
</p>

<p>
\[\Sigma \proves t_1=t_3.\]
</p>

<p>
So \(t_1\sim _\Sigma t_3\). Therefore \(\sim _\Sigma \) is transitive.
</p>

<p>
(ii) I will do the case where \(F\) is a unary function symbol. Suppose that \(\Sigma \proves t=s\). We need to show that \(\Sigma \proves F(t)=F(s)\). Let \(x,y,z\in \Vbl \) which are distinct and don’t occur in \(t\) or \(s\).
</p>

<p>
By <b>(AxEq)</b>,
</p>

<p>
\[\proves x=y\rightarrow (z=F(x)\rightarrow z=F(y)).\]
</p>

<p>
By <b>(AxSub)</b>,
</p>

<p>
\[\proves t=s\rightarrow (z=F(t)\rightarrow z=F(s)).\]
</p>

<p>
Using modus ponens,
</p>

<p>
\[\Sigma \proves z=F(t)\rightarrow z=F(s).\]
</p>

<p>
Using <b>(AxSub)</b>,
</p>

<p>
\[\Sigma \proves F(t)=F(t)\rightarrow F(t)=F(s).\]
</p>

<p>
Since
</p>

<p>
\[\proves \forall x \, x=x,\]
</p>

<p>
by <b>(AxSub)</b> and modus ponens,
</p>

<p>
\[\Sigma \proves F(t)=F(t).\]
</p>

<p>
Therefore, by modus ponens,
</p>

<p>
\[\Sigma \proves F(t)=F(s)\]
</p>

<p>
as required.
</p>

<p>
(iii) This is a similar nightmare to (ii).
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-278"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.4</span></span><span class="amsthmnoteplain"> (The term algebra)</span>. </span> Let \(\mcal {L}\) be a language with at
least one constant symbol and let \(\Sigma \subseteq \Fml (\mcal {L})\). We define an \(\mcal {L}\)-structure \(\TmAlg (\Sigma )\) called the <b>term algebra of \(\Sigma \)</b>. The domain of \(\TmAlg (\Sigma )\) is
</p>

<p>
\[\ctm (\mcal {L})/\sim _\Sigma .\]
</p>

<p>
We write \([t]_\Sigma \) for the \(\sim _\Sigma \)-equivalence class of \(t\).
</p>

<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> For each relation symbol \(R\) of \(\mcal {L}\) of arity \(n\), we define
</p>
<p>
\[R^{\TmAlg (\Sigma )}:=\{([t_1]_\Sigma ,\ldots ,[t_n]_\Sigma )\st \Sigma \proves R(t_1,\ldots ,t_n)\}.\]
</p>
</li>
<li>


<p>
<span class="listmarker">(ii)</span> For each function symbol \(F\) of \(\mcal {L}\) of arity \(n\) we define
</p>
<p>
\[F^{\TmAlg (\Sigma )}([t_1]_\Sigma ,\ldots ,[t_n]_\Sigma )=[F(t_1,\ldots ,t_n)]_\Sigma .\]
</p>
</li>
<li>


<p>
<span class="listmarker">(iii)</span> For \(c\) a constant symbol of \(\mcal {L}\) we define
</p>
<p>
\[c^{\TmAlg (\Sigma )}:=[c]_\Sigma .\]
</p>
<p>


</p>
</li>
</ul>

<p>
For a single formula \(\sigma \), we define the term algebra of \(\sigma \) to be \(\TmAlg (\{\sigma \})\).
</p>

</li>

</ul>

</div>

<p>
We do some examples.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-279"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">4.5</span></span>. </span> <a id="termalgex"></a>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\mcal {L}:=\langle c\rangle \) where \(c\) is a constant symbol. Then \(\ctm (\mcal {L})\) has just one element \(c\). This means that no matter what set of \(\mcal {L}\)-sentences with pick,
\(\TmAlg (\Sigma )\) has just one element. Let \(\Sigma =\{\exists v_1 \, v_1\neq c \}\). Then \(\TmAlg (\Sigma )\) is the \(\mcal {L}\)-structure with domain \(\{[c]_\Sigma \}\) \(c\) interpreted as \([c]_\Sigma \). Note, \(\TmAlg
(\Sigma )\) is not a model of \(\Sigma \) in this case.
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> Let \(\mcal {L}:=\langle R, c,d,e\rangle \) where \(R\) is a unary relation symbol and \(c,d,e\) are constant symbols. Then \(\ctm (\mcal {L})\) has \(3\) elements \(c,d,e\). Let \(\sigma \) be
the formula \(c=d\vee c=e\). The term algebra of \(\sigma \) has at most \(3\) elements \([c]_\sigma ,[d]_\sigma \) and \([e]_\sigma \).
</p>
<p>
We can check using the soundness theorem that \(\sigma \nvdash c=d\), \(\sigma \nvdash c=e\) and \(\sigma \nvdash d=e\). I will show that \(\sigma \nvdash c=d\). By the Soundness Theorem, \(\sigma \nvDash c=d\) implies \(\sigma
\nvdash c=d\). Let \(\mcal {M}\) be the \(\mcal {L}\)-structure with domain \(\{1,2\}\), \(R^{\mcal {M}}:=\{1,2\}\) and
</p>
<p>
\[c^{\mcal {M}}:=1, d^{\mcal {M}}:=2 \text { and } e^{\mcal {M}}=1.\]
</p>
<p>
Then \(\mcal {M}\models c=d\vee c=e\) because \(c^{\mcal {M}}=e^{\mcal {M}}\). But \(\mcal {M}\nvDash c=d\). Therefore \(\sigma \nvDash c=d\). So \(\sigma \nvdash c=d\) as required.
</p>
<p>
This shows that \(\TmAlg (\sigma )\) has \(3\) elements \([c]_\sigma ,[d]_\sigma \) and \([e]_\sigma \). I claim \(R^{\TmAlg (\sigma )}=\emptyset \). To show this, we should show that \(\sigma \nvdash R(t)\) for all \(t\in \ctm
(\mcal {L})\). Let \(\mcal {M}\) be the \(\mcal {L}\)-structure with domain \(\{1\}\) and \(R^{\mcal {M}}=\emptyset \). Then \(\mcal {M}\models \sigma \) but \(\mcal {M}\nvDash R(t)\) for all \(t\in \ctm (\mcal {L})\) because
\(R^{\mcal {M}}=\emptyset \).
</p>
<p>


</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-280"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.6</span></span>. </span> <a id="tmalggoodat"></a> Let \(\mcal {L}\) be a language with at least one constant symbol and let
\(\Sigma \subseteq \Fml (\mcal {L}) \). Let \(n\in \N \), \(t_1,...,t_n\in \ctm (\mcal {L}) \), \(x_1,...,x_n\in \Vbl \) pairwise distinct and let \(h\) be an assignment of \(\TmAlg (\Sigma ) \) with \(h(x_i)=[t_i]_\Sigma \)
\((1\leq i\leq n)\).
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> If \(t(x_1,...,x_n)\in \tm (\mcal {L}) \) then \(t^{\TmAlg (\Sigma ) }[h]=[t(x_1/t_1,...,x_n/t_n)]_\Sigma \).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \(\phi (x_1,...,x_n)\in \Fml (\mcal {L}) \) is atomic then
</p>
<p>
\[\TmAlg (\Sigma ) \models \phi [h]\text { if and only if } \Sigma \vdash \phi (x_1/t_1,...,x_n/t_n).\]
</p>
<p>


</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-281"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (i) The first statement is proved by induction on the complexity of the term \(t\). If \(t\) has complexity \(0\) then \(t\) is either a variable or a constant
symbol.
</p>

<p>
Suppose \(t\) is the variable \(x_i\) for some \(1\leq i\leq n\). Then \(t(x_1/t_1,\ldots ,x_n/t_n)\) is \(t_i\) and \(t^\TmAlg (\Sigma )[h]=h(x_i)\). By assumption, \(h(x_i)=[t_i]_{\Sigma }\). Therefore \(t^{\TmAlg (\Sigma )
}[h]=[t(x_1/t_1,...,x_n/t_n)]_\Sigma \) as required.
</p>

<p>
Suppose \(t\) is a constant symbol \(c\). Then \(t(x_1/t_1,\ldots ,x_n/t_n)\) is \(c\) and \(t^\TmAlg (\Sigma )[h]=c^{\TmAlg (\Sigma )}\). By definition of \(\TmAlg (\Sigma )\), \(c^{\TmAlg (\Sigma )}=[c]_{\Sigma }\). So we get
the required conclusion.
</p>

<p>
Now suppose that for all terms \(t\) of complexity less than or equal to \(n\), \((i)\) holds. Suppose \(s\in \tm _{n+1}(\mcal {L})\). Then \(s\) is of the form \(F(s_1,\ldots ,s_m)\) for \(F\) a function symbol of arity \(m\) and terms
\(s_i\in \tm _n(\mcal {L})\). By definition, \(F(s_1,\ldots ,s_m)[h]=F^{\TmAlg (\Sigma )}(s_1[h],\ldots ,s_m[h])\). By the induction hypothesis,
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<p>


\begin{eqnarray*}
F^{\TmAlg (\Sigma )}(s_1[h],\ldots ,s_m[h]) &amp;=&amp; F^{\TmAlg (\Sigma )}([s_1(x_1/t_1,...,x_n/t_n)]_\Sigma ,\ldots ,[s_m(x_1/t_1,...,x_n/t_n)]_\Sigma ) \\ &amp;=&amp; [F(s_1(x_1/t_1,...,x_n/t_n),\ldots
,s_m(x_1/t_1,...,x_n/t_n))]_\Sigma \\ &amp;=&amp; [s(x_1/t_1,\ldots ,x_n/t_n)]_\Sigma .
\end{eqnarray*}


</p>

<p>
(ii) This is an application of (i) and the definition of the term algebra. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We’ve seen that the term algebra of a set of sentences \(\Sigma \) is not always a model of \(\Sigma \). In the 2 cases we have seen there are ways to fix this.
</p>

<p>
We first consider <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#termalgex">4.5</a>(i). Let \(\mcal {L}:=\langle c\rangle \) where \(c\) is a constant symbol and let \(\sigma \) be the formula \(\exists
v_1 v_1\neq c\). In order to make the term algebra of \(\Sigma :=\{\sigma \}\) into a model of \(\sigma \) we can extend the language \(\mcal {L}\) by a constant \(c_{\sigma }\) to get \(\mcal {L}(c_{\sigma })\) and replace \(\Sigma \) with
</p>

<p>
\[\{\sigma , (\exists v_1 \, v_1\neq c)\rightarrow c_\sigma \neq c\}.\]
</p>

<p>
Then \(\TmAlg (\Sigma )\models \sigma \).
</p>

<p>
Now consider <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#termalgex">4.5</a>(ii). Let \(\mcal {L}:=\langle R,c,d,e\rangle \) and let \(\sigma \) be \(c=d\vee c=e\). If we replace \(\Sigma
:=\{\sigma \}\) with a consistent set of \(\mcal {L}\)-sentences \(\Sigma ^+\) containing \(\Sigma \) such that for all \(\mcal {L}\)-sentences \(\phi \), either \(\phi \in \Sigma ^+\) or \(\neg \phi \in \Sigma ^+\) then a little work will allow
you to conclude that either \(c=d\in \Sigma ^+\) or \(c=e\in \Sigma ^+\). This will force \(\TmAlg (\Sigma ^+)\) to be a model of \(\sigma \).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-282"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.7</span></span>. </span> Let \(\mcal {L}\) be a language with set of constant symbols \(\mcal {C}\). We write \(\Fml (\mcal
{L})(1)\) for the set of all \(\mcal {L}\)-formulas with at most one free variable.
</p>

<p>
Let \(\Sigma \) be a set of \(\mcal {L}\)-sentences. A <b>system of witnesses</b> for \(\Sigma \) is a map
</p>

<p>
\[\gamma :   \Fml (\mcal {L})(1)\rightarrow \mcal {C}\]
</p>

<p>
such that for all \(x\in \Vbl \) and all \(\phi (x)\in \Fml (\mcal {L})(1)\) we have
</p>

<p>
\[\Sigma \proves (\exists x\, \phi )\rightarrow \phi (x/\gamma (\phi )).\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-283"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4.8</span></span>. </span> An <b>\(\mcal {L}\)-theory</b> is a consistent set of \(\mcal {L}\)-sentences. An \(\mcal
{L}\)-theory \(T\) is <b>complete</b> if for all \(\mcal {L}\)-sentences \(\phi \), either \(\phi \in T\) or \(\neg \phi \in T\).
</p>

</li>

</ul>

</div>

<p>
The set of sentences satisfied by an \(\mcal {L}\)-structure is an example of a complete theory (in fact, all complete theories are of this form but we need the Completeness Theorem to prove this).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-284"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.9</span></span>. </span> <a id="TmAlgmodel"></a> If \(\Sigma \) is a complete \(\mcal {L}\)-theory which has a system of
witnesses then the term algebra of \(\Sigma \) is a model of \(\Sigma \).
</p>

</li>

</ul>

</div>

<p>
We can use the Completeness Theorem for Propositional Logic to prove 1. and 2. of the following lemma.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-285"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.10</span></span>. </span> <a id="dedweneed"></a> Let \(\Sigma \) be a complete \(\mcal {L}\)-theory. Then
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(\Sigma \proves \phi \) if and only if \(\phi \in \Sigma \);
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(\phi _1\rightarrow \phi _2\in \Sigma \) if and only if \(\phi _1,\phi _2\in \Sigma \) or \(\phi _1\notin \Sigma \); and
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(\forall y\,\psi \notin \Sigma \) implies \(\exists y\, \neg \psi \in \Sigma \).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
This proof is why we are first proving the completeness theorem for sets of sentences. Essentially it would be much more confusing if we tried to prove a version for formulas.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-286"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of Proposition <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#TmAlgmodel">4.9</a>.</span></span> We prove by induction on the
complexity of \(\phi (x_1,\ldots ,x_n)\in \Fml (\mcal {L})\) that: For all constant terms \(t_1,\ldots ,t_n\),
</p>

<p>
\[\phi (x_1/t_1,\ldots ,x_n/t_n)\in \Sigma \text { if and only if } \TmAlg (\Sigma )\models \phi (x_1/t_1,\ldots ,x_n/t_n).                 \tag {$\dagger $}\]
</p>

<p>
If \(\phi \) is atomic then this is <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#tmalggoodat">4.6</a>. The case when \(\phi \) is \(\bot \) follows from the fact that \(\Sigma \) is consistent.
</p>

<p>
Suppose \((\dagger )\) is true for \(\phi _1\) and \(\phi _2\). We show that \((\dagger )\) is true for \(\phi _1\rightarrow \phi _2\).
</p>

<p>
Since \(\Sigma \) is complete, \(\phi _1\rightarrow \phi _2\in \Sigma \) if and only if \(\phi _1,\phi _2\in \Sigma \) or \(\phi _1\notin \Sigma \). Since \((\dagger )\) holds for \(\phi _1\) and \(\phi _2\),
</p>

<p>
\[ \TmAlg (\Sigma )\models \phi _1(x_1/t_1,\ldots ,x_n/t_n) \text { and } \TmAlg (\Sigma )\models \phi _2(x_1/t_1,\ldots ,x_n/t_n),\]
</p>

<p>
or
</p>

<p>
\[\TmAlg (\Sigma )\nvDash \phi _1(x_1/t_1,\ldots ,x_n/t_n).\]
</p>

<p>
Considering Tarski’s Truth definition, this is true if and only if
</p>

<p>
\[\TmAlg (\Sigma )\models \phi _1(x_1/t_1,\ldots ,x_n/t_n)\rightarrow \phi _2(x_1/t_1,\ldots ,x_n/t_n).\]
</p>

<p>
We now need to consider the case where \(\phi \) is \(\forall y \, \psi \) for some \(y\in \Vbl \). Suppose \((\dagger )\) is true for \(\psi \). By definition, \(y\) is not a free variable of \(\phi \). Since \(\Fr (\phi )\subseteq
\{x_1,\ldots ,x_n\}\), no harm is done by assuming that \(y\neq x_i\) for \(1\leq i\leq n\).
</p>

<p>
We first prove the forward direction of \((\dagger )\) for \(\phi \). Suppose \(\phi (x_1/t_1,\ldots ,x_n/t_n)\in \Sigma \). Then \(\forall y\,\psi (x_1/t_1,\ldots ,x_n/t_n,y)\in \Sigma \). By the substitution axiom \(\Sigma
\proves \psi (x_1/t_1,\ldots ,x_n/t_n,y/t)\) for all constant terms \(t\). Thus, by the induction hypothesis,
</p>

<p>
\[\TmAlg (\Sigma )\models \psi (x_1/t_1,\ldots ,x_n/t_n,y/t).\]
</p>

<p>
Therefore
</p>

<p>
\[\TmAlg (\Sigma )\models \psi (x_1/t_1,\ldots ,x_n/t_n)[h]\]
</p>

<p>
for all \(h\) with \(h(y)=[t]_\Sigma \). Since \(t\) was an arbitrary constant term, this means
</p>

<p>
\[\TmAlg (\Sigma )\models \phi (x_1/t_1,\ldots ,x_n/t_n)\]
</p>

<p>
as we wanted.
</p>

<p>
We now prove the reverse direction of \((\dagger )\) for \(\phi \). This is where we need that \(\Sigma \) has a system of witnesses. Let
</p>

<p>
\[\gamma :\Fml (\mcal {L})(1)\rightarrow \mcal {C}\]
</p>

<p>
be a system of witnesses for \(\Sigma \).
</p>

<p>
Suppose \(\TmAlg (\Sigma )\models \forall y \,\psi (x_1/t_1,\ldots ,x_n/t_n,y)\) but \(\forall y\,\psi (x_1/t_1,\ldots ,x_n/t_n,y)\notin \Sigma \) with the intention of deriving a contradition. Since \(\Sigma \) is complete, by
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#dedweneed">4.10</a>, \(\exists y \, \neg \psi (x_1/t_1,\ldots ,x_n/t_n,y)\in \Sigma \). Let \(c:=\gamma (\neg \psi (x_1/t_1,\ldots
,x_n/t_n,y))\). Since \(\gamma \) is a system of witnesses for \(\Sigma \) we have
</p>

<p>
\[\Sigma \proves \exists y \, \neg \psi (x_1/t_1,\ldots ,x_n/t_n,y)\rightarrow \neg \psi (x_1/t_1,\ldots ,x_n/t_n,y/c).\]
</p>

<p>
Then modus ponens gives
</p>

<p>
\[\Sigma \proves \neg \psi (x_1/t_1,\ldots ,x_n/t_n,y/c)\]
</p>

<p>
Hence \(\psi (x_1/t_1,\ldots ,x_n/t_n,y/c)\notin \Sigma \). Since \((\dagger )\) holds for \(\psi \), this implies
</p>

<p>
\[\TmAlg (\Sigma )\nvDash \psi (x_1/t_1,\ldots ,x_n/t_n,y/c).\]
</p>

<p>
But then by <a href="Tarski-Truth-Definition.html#sublemma">3.45</a>, this contradicts our assumption that
</p>

<p>
\[\TmAlg (\Sigma )\models \forall y\,\psi (x_1/t_1,\ldots ,x_n/t_n).\]
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Adding witnesses ......
-->
<h6 id="autosec-287">Adding witnesses</h6>
<a id="Logic-autopage-287"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-288"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.11</span></span>. </span> <a id="addingwitnesses"></a> Let \(\mcal {L}\) be a language and let \(\Sigma \) be a set of
\(\mcal {L}\)-formulas. Let \(\gamma :\Fml (\mcal {L})(1)\rightarrow \mcal {D}\) be a bijection onto a some set of constant symbols disjoint from those of \(\mcal {L}\). If \(\Sigma \) is consistent then so is the set of \(\mcal {L}(\mcal
{D})\)-sentences
</p>

<p>
\[\Sigma ^W:=\Sigma \cup \{\exists x\,\phi (x)\rightarrow \phi (x/\gamma (\phi )) \st \phi \in \Fml (\mcal {L})(1)\}.\]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
In order to prove this we need some not totally trivial facts.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-289"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.12</span></span>. </span> <a id="constbyvar"></a> Let \(\mcal {L}\) be a language, let \(\Sigma \) a set of \(\mcal
{L}\)-formulas and let \(c\) be a constant symbol which is not a constant symbol of \(\mcal {L}\). Suppose that \(y\) is a variable that does not occur in \(\phi \). Let \(\phi _y^c\) be the result of replacing every instance of \(c\) in \(\phi \)
by \(y\). Then \(\Sigma \proves _{\mcal {L}(c)} \phi \) implies \(\Sigma \proves _{\mcal {L}}\phi _y^c\).
</p>

<p>
Here \(\proves _\mcal {L}\) indicates that there is an “\(\mcal {L}\)-deduction” of \(\phi \) from \(\Sigma \).
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-290"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Omitted for now. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-291"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.13</span></span>. </span> Let \(\mcal {L}\) be a language, \(\mcal {D}\) a set of constant symbols disjoint from those of \(\mcal
{L}\). Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas and \(\phi \) an \(\mcal {L}\)-formula. Then
</p>

<p>
\[\Sigma \proves _\mcal {L} \phi \text { if and only if }\Sigma \proves _{\mcal {L}(\mcal {D})}\phi .\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-292"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Omitted for now. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-293"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.14</span></span>. </span> <a id="Adedforwit"></a> Let \(\phi ,\psi \) be \(\mcal {L}\)-formulas and \(\Sigma \) a set of
\(\mcal {L}\)-formulas.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> If \(y\) does not occur free in \(\phi \) then \(\proves \forall y\,\phi (x/y)\rightarrow \forall x \, \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> If \(\Sigma \proves \phi \rightarrow \psi \) then \(\Sigma \proves \neg \psi \rightarrow \neg \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> \(\proves (\phi \rightarrow \exists x\,\psi )\rightarrow \exists x\,(\phi \rightarrow \psi )\)
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-294"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Omitted for now. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-295"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">4.15</span></span>. </span> If \(\Sigma \) has a system of witnesses and \(\Sigma ^*\) is a complete theory containing \(\Sigma
\) then \(\Sigma ^*\) has a system of witnesses (the same system works with no changes).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-296"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#addingwitnesses">4.11</a>.</span></span>
</p>

<p>
<b>Claim:</b> If \(\Sigma \) is a finite consistent set of sentences and \(\phi \in \Fml (\mcal {L})(1)\) is such that \(\gamma (\phi )\) does not occur in any \(\sigma \in \Sigma \) then
</p>

<p>
\[\Sigma &apos;:=\Sigma \cup \{\exists x\,\phi (x)\rightarrow \phi (x/\gamma (\phi ))\}\]
</p>

<p>
is consistent.
</p>

<p>
Suppose for a contradiction that \(\Sigma &apos;\proves \bot \). By the deduction theorem \(\Sigma \proves \neg (\exists x\,\phi (x)\rightarrow \phi (x/\gamma (\phi )))\). Let \(y\) be a variable that does not occur in any formula
in \(\Sigma &apos;\) and let \(\psi :=\exists x\,\phi (x)\rightarrow \phi (x/y)\). By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#constbyvar">4.12</a>, \(\Sigma \proves \neg \psi \). The
Generalisation Theorem now implies \(\Sigma \proves \forall y \, \neg \psi \). Since \(\exists y\,\psi \) is an abbreviation for \(\neg \forall y\, \neg \psi \), it is enough to show \(\Sigma \proves \exists y\,\psi \) because this
implies \(\Sigma \proves \bot \). By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#Adedforwit">4.14</a>, \(\Sigma \proves \forall y\,(\neg \phi (x/y))\rightarrow \forall x\, \neg \phi \).
By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#Adedforwit">4.14</a>, \(\Sigma \proves \neg \forall x\,\neg \phi \rightarrow \neg \forall y(\neg \phi (x/y))\), i.e., \(\Sigma \proves
\exists x\phi \rightarrow \exists y\, \phi (x/y)\). By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#Adedforwit">4.14</a>, \(\Sigma \proves \exists y\, (\exists x\,\phi \rightarrow \phi
(x/y))\), i.e., \(\Sigma \proves \exists y\, \psi \). So \(\Sigma \proves \bot \). This contradicts our assumption that \(\Sigma \) is consistent. Therefore \(\Sigma &apos;\) is consistent.
</p>

<p>
We now prove the proposition based on the claim. Suppose \(\Sigma ^W\proves \bot \). Since proofs are finite, \(\Sigma _0\proves \bot \) for some finite subset \(\Sigma _0\) of \(\Sigma ^W\). We may assume that \(\Sigma _0\) is of
minimal size with this property. Since \(\Sigma \) is consistent, this means there is some consistent set \(\Sigma _0&apos;\) and some \(\phi \in \Fml (\mcal {L})(1)\) such that \(\Sigma _0=\Sigma _0&apos;\cup \{\exists x\,\phi
(x)\rightarrow \phi (x/\gamma (\phi ))\}\). But \(\Sigma _0\) being inconsistent contradicts the claim. Thus \(\Sigma ^W\) is consistent. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We are not quite there because there is no reason that all \(\mcal {L}(\mcal {D})\)-formulas in one free variable should have witnesses.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-297"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.16</span></span>. </span> <a id="extendwit"></a> Let \(\Sigma \) be a consistent set of \(\mcal {L}\)-sentences. There is
an extension \(\mcal {L}^+\) of \(\mcal {L}\) by constants and a consistent set of \(\mcal {L}^+\)-sentences \(\Sigma ^+\supseteq \Sigma \) such that \(\Sigma ^+\) has a system of witnesses.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-298"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We iterate the construction from <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#addingwitnesses">4.11</a>. Define
\(\mcal {L}_0:=\mcal {L}\) and \(\Sigma _0:=\Sigma \). For \(i\in \N _0\), let \(\mcal {L}_{i+1}:=(\mcal {L}_i)^W\) where \(\mcal {L}_i^{W}\) denotes the language \(\mcal {L}(\mcal {D})\) from <a
href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#addingwitnesses">4.11</a> and \(\Sigma _{i+1}:=(\Sigma _i)^W\) is as in the statement of <a
href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#addingwitnesses">4.11</a>. Then \(\mcal {L}_\infty :=\bigcup _{i\in \N _0}\mcal {L}_i\) is an extension of \(\mcal {L}\) by constants and \(\Sigma
_\infty :=\bigcup _{i\in \N _0}\Sigma _i\) is a consistent set of \(\mcal {L}_\infty \)-sentences containing \(\Sigma \). To see that \(\Sigma _\infty \) is consistent note that, since “Proofs are finite”, if \(\Sigma _\infty \proves \bot
\) then \(\Sigma _i\proves \bot \) for some \(i\in \N _0\). By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#addingwitnesses">4.11</a>, each \(\Sigma _i\) is consistent. Moreover \(\Sigma _\infty
\) has a set of witnesses because every \(\mcal {L}_\infty \)-formula \(\phi \) is an \(\mcal {L}_i\)-formula for some \(i\in \N _0\). By construction, if \(\phi \in \Fml (\mcal {L}_i)(1)\) then \(\phi \) “has a witness” gains a witness in
\(\mcal {L}_{i+1}.\) <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Every consistent set of sentences is contained in a complete theory.                       ......
-->
<h6 id="autosec-299">Every consistent set of sentences is contained in a complete theory.</h6>
<a id="Logic-autopage-299"></a>


<p>
This is the only point in the proof where use the fact that \(\mcal {L}\) is countable. Everything here works as it does for Propositional Logic. For this reason, I may not lecture this bit but I do expect you (4th years and PhD students) to be able to produce
the proofs in this subsection in an exam.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-300"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">4.17</span></span>. </span> <a id="conext"></a> Let \(\Sigma \) be a consistent set of \(\mcal {L}\)-sentences and let \(\phi \)
be an \(\mcal {L}\)-sentence. Then either \(\Sigma \cup \{\phi \}\) is consistent or \(\Sigma \cup \{(\neg \phi )\}\) is consistent.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-301"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose \(\Sigma \cup \{\phi \}\proves \bot \). Then, by the Deduction Theorem, \(\Sigma \models (\phi \rightarrow \bot )\), i.e., \(\Sigma
\proves (\neg \phi )\). Hence \(\Sigma \cup \{(\neg \phi )\}\) is consistent. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-302"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">4.18</span></span>. </span> <a id="extcomp"></a> Let \(X\) be a consistent set of \(\mcal {L}\)-sentences. There exists a
complete \(\mcal {L}\)-theory \(T\) such that \(X\subseteq T\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-303"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We proceed exactly as we did in the proof of <a href="Completeness.html#adequ">2.52</a> for Propositional Logic. Let \(\phi _1,\phi _2,\ldots \) be an
enumeration of the \(\mcal {L}\)-formulas. Define \(\Sigma _1:=X\). For each \(i\), let \(\Sigma _{i+1}:=\Sigma _i\cup \{\phi \}\) if it is consistent and let \(\Sigma _{i+1}:=\Sigma _i\cup \{(\neg \phi _i)\}\) otherwise. In either case,
\(\Sigma _{i+1}\) is consistent by <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#conext">4.17</a>. Let \(\Sigma _*:=\bigcup _{i\in \N }\Sigma _i\). Suppose for a contradiction that \(\Sigma _*\) is
not consistent. Then \(\Sigma _*\proves \bot \). Since “Proofs are finite” there is some finite subset \(\Sigma &apos;\subseteq \Sigma _*\) such that \(\Sigma &apos;\proves \bot \). But then, by definition of \(\Sigma _*\), \(\Sigma
&apos;\subseteq \Sigma _i\) for some \(i\in \N \) and hence \(\Sigma _i\proves \bot \) which give a contradiction. Thus \(\Sigma _*\) is consistent. By definition, for all \(\mcal {L}\)-sentences \(\phi \), either \(\phi \in \Sigma _*\)
or \((\neg \phi )\in \Sigma _*\). Therefore \(\Sigma _*\) is complete. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Finishing of the proof ......
-->
<h6 id="autosec-304">Finishing of the proof</h6>
<a id="Logic-autopage-304"></a>


<p>
We prove the Model Existence Theorem.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-305"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#ModelExThm">4.1</a>.</span></span> Let \(\Sigma \) be a consistent set of \(\mcal
{L}\)-sentences. By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#extendwit">4.16</a>, there exists \(\mcal {L}^+\) an extension of \(\mcal {L}\) by constants and a set \(\Sigma ^+\supseteq \Sigma \)
of \(\mcal {L}^+\)-sentences such that \(\Sigma ^+\) has a system of witnesses. By <a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#extcomp">4.18</a>, there is a complete \(\mcal {L}^+\)-theory \(\Sigma
^*\) containing \(\Sigma ^+\). As we have already observed, \(\Sigma ^*\) has a system of witnesses because \(\Sigma ^+\) does. Therefore \(\TmAlg (\Sigma ^*)\models \Sigma ^*\). Hence the \(\mcal {L}\)-reduct of \(\TmAlg (\Sigma
^*)\) is a model of \(\Sigma \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We now reduce a version of the Model Existence Theorem for formulas to the case of sentences.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-306"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">4.19</span></span>. </span> Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas. If \(\Sigma \models \bot \) then \(\Sigma
\proves \bot \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-307"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Full proof is omitted (at least for now). Essentially, you replace any free variables of formulas in \(\Sigma \) by constant symbols. Suppose \(\Sigma \nvdash
\bot \). Let \(\mcal {D}:=\{c_i\st i\in \N \}\) be a set of constant symbols. For \(\sigma \in \Fml (\mcal {L})\), let \(\sigma (\mcal {D})\) be the formula obtained from \(\sigma \) by replacing all free instances of \(v_i\) by \(c_i\).
Let \(\Sigma (\mcal {D}):=\{\sigma (\mcal {D})\st \sigma \in \Sigma \}\). It follows, with some work, that \(\Sigma (\mcal {D})\nvdash \bot \). Thus, by the Model Existence Theorem, there is an \(\mcal {L}(\mcal {D})\)-structure
\(\mcal {M}\) such that \(\mcal {M}\models \Sigma (\mcal {D})\). Now, let \(h\) be an assignment of \(\mcal {M}\) where \(h(v_i)=c_i^\mcal {M}\) for all \(i\in \N \). Then \(h\) is also an assignment of the \(\mcal {L}\)-reduct \(\mcal
{M}^{-}\) of \(\mcal {M}\). With a bit of work, we can show that \(\mcal {M}^{-}\models \sigma [h]\) for all \(\sigma \in \Sigma \). Therefore \(\Sigma \nvDash \bot \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We can now deduce the difficult direction of the Completeness Theorem exactly as we did in Propositional Logic.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-308"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of the Completeness Theorem for Predicate Logic.</span></span> Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas and let \(\phi \) be an \(\mcal {L}\)-formula. By the
Soundness Theorem \(\Sigma \proves \phi \) implies \(\Sigma \models \phi \). We now prove the converse. Suppose that \(\Sigma \models \phi \). Let \(\mcal {M}\) be an \(\mcal {L}\)-structure and let \(h\) be an assignment of \(\mcal
{M}\). Suppose that \(\mcal {M}\models \sigma [h]\) for all \(\sigma \in \Sigma \). Since \(\Sigma \models \phi \), \(\mcal {M}\models \phi [h]\). Thus, \(\mcal {M}\nvDash \neg \phi [h]\). Therefore \(\Sigma \cup \{\neg \phi
\}\models \bot \). So, by the Model Existence Theorem, \(\Sigma \cup \{\neg \phi \}\proves \bot \). By the Deduction Theorem, this implies \(\Sigma \proves (\neg \phi )\rightarrow \bot \) i.e. \(\Sigma \proves \neg \neg \phi
\). Since \(\neg \neg \phi \rightarrow \phi \) is an instance of <b>(AxProp)</b>, applying modus ponens gives \(\Sigma \proves \phi \) as required. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Application-Compactness-Theorem-Extension-Constants.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Application of the Compactness Theorem and Extension by Constants</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-309"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Application of the Compactness Theorem and Extension by Constants ......
-->
<h4 id="autosec-310"><span class="sectionnumber">5&#x2003;</span>Application of the Compactness Theorem and Extension by Constants</h4>
<a id="Logic-autopage-310"></a>
<a id="Logic-autofile-12"></a>

<a id="appcomp"></a>

<p>
We saw a few applications of the Compactness Theorem for propositional logic but these were really just exercises in how to use the Compactness Theorem. The Compactness Theorem for predicate logic is the first theorem in Model Theory. Model Theory is a
branch of mathematical logic with close ties and strong applications to the rest of pure mathematics. In particular, there are applied model theorists studying the model theory of most other parts of pure mathematics. There is an alternative model theoretic proof
of the compactness theorem.
</p>

<p>
We start with some consequences of the Compactness Theorem, some of which might be viewed as negative or showing the limits of first order logic.
</p>

<p>
On Exercise Sheet \(7\), we introduced the following definition.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-311"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5.1</span></span>. </span> We say that a class \(X\) of \(\mcal {L}\)-structures is <b>axiomatisable</b> if there exists a set of
\(\mcal {L}\)-sentences \(\Sigma \) such that for all \(\mcal {L}\)-structures \(\mcal {M}\),
</p>
<div class="center">

<p>
\(\mcal {M}\models \phi \) for all \(\phi \in \Sigma \) if and only if \(\mcal {M}\in X\).
</p>
</div>

<p>
We call \(\Sigma \) an <b>axiomatisation</b> of \(X\) or that \(\Sigma \) <b>axiomatises</b> \(X\).
</p>

</li>

</ul>

</div>

<p>
We say an \(\mcal {L}\)-structure is finite/infinite if its domain is finite/infinite. The size (or cardinality) of an \(\mcal {L}\)-structure is the size of its domain.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-313"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">5.2</span></span>. </span> Let \(\mcal {L}\) be a language.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> For each \(n\in \N \), there is an \(\mcal {L}\)-sentence \(\sigma _n\) such that \(\mcal {M}\models \sigma _n\) if and only if \(\mcal {M}\) has size \(n\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> There is a set of \(\mcal {L}\)-sentences which axiomatise the class of infinite \(\mcal {L}\)-structures.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-314"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Exercise Sheets \(7\) and \(8\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-315"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.3</span></span>. </span> <a id="finiteunbounded"></a> Let \(X\) be an axiomatisable class of \(\mcal {L}\)-structures such
that for every \(n\in \N \) there is an \(\mcal {L}\)-structure \(\mcal {M}\in X\) such that the domain of \(\mcal {M}\) has more than \(n\) elements. Then \(X\) contains an infinite \(\mcal {L}\)-structure.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-316"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Let \(\Sigma \) be the set of \(\mcal {L}\)-sentences which axiomatise \(X\). For each \(n\in \N \), let \(\sigma _n\) be an \(\mcal {L}\)-sentence such
that \(\mcal {M}\models \sigma _n\) if and only if \(\mcal {M}\) has size \(n\). We will show that \(\Sigma \cup \{\neg \sigma _n\st n\in \N \}\) is satisfiable using the Compactness Theorem. Let \(\Sigma &apos;\subseteq \Sigma \cup
\{\neg \sigma _n\st n\in \N \}\) be finite. Since \(\Sigma &apos;\) is finite, there exists \(l\in \N \) such that if \(\neg \sigma _n\in \Sigma &apos;\) then \(n\leq l\). Take \(\mcal {M}\in X\) such that the size of \(\mcal {M}\) has at
least \(l+1\) elements. Then \(\mcal {M}\) is a model of \(\Sigma \) and \(\mcal {M}\models \neg \sigma _n\) for all \(n\leq l\). Therefore \(\mcal {M}\) is a model of \(\Sigma &apos;\). So, we have shown that all finite subsets of \(\Sigma
\cup \{\neg \sigma _n\st n\in \N \}\) have a model. Therefore, by the Compactness Theorem, \(\Sigma \cup \{\neg \sigma _n\st n\in \N \}\) has a model \(\mcal {M}^*\). Since \(\mcal {M}^*\) satisfies \(\Sigma \), \(\mcal {M}^*\in
X\). For each \(n\in \N \), \(\mcal {M}^*\models \neg \sigma _n\). So \(\mcal {M}^*\) is not size \(n\) for any \(n\in \N \). Therefore \(\mcal {M}^*\) is infinite.
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">20.11.23</span>
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-317"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">5.4</span></span>. </span> There is an infinite group \(G\) which satisfies all sentences \(\phi \) in \(\mcal {L}_{gp}:=\langle
\cdot , (-)^{-1}, e\rangle \) that are true in all finite groups. We call such a group a <b>psuedofinite group</b>.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-318"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Let \(\Sigma \) be the set of \(\mcal {L}_{gp}\)-sentences \(\phi \) such that \(\phi \) is satisfied by all finite groups. By definition, all finite groups are
models of \(\Sigma \). For each natural number \(n\), the group \((\Z /n\Z ,+)\) has size \(n\). Thus, by reffiniteunbounded, \(\Sigma \) has an infinite model. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
This might be viewed as a negative consequence of the Compactness Theorem.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-319"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">5.5</span></span>. </span> The class of finite groups, graphs, rings, fields, etc are not axiomatisable (in the appropriate first order
language).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-320"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Each of the classes has members of unbounded finite size. So, by <a
href="Application-Compactness-Theorem-Extension-Constants.html#finiteunbounded">5.3</a>, if \(\Sigma \) is a set of sentences satisfied by all members of the class then \(\Sigma \) has an infinite model. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-321"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.6</span></span>. </span> Let \(\mcal {L}\) be a language. There does not exist an \(\mcal {L}\)-sentence which axiomatises
the class of infinite \(\mcal {L}\)-structures.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-322"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose for a contradiction that \(\phi \) is an \(\mcal {L}\)-sentence which axiomatises the class of infinite \(\mcal {L}\)-structures. Then, \(\neg \phi \)
axiomatises the class of finite \(\mcal {L}\)-structures. So it is enough to show that the class of finite \(\mcal {L}\)-structures is not axiomatisable. For each \(n\in \N \), let \(\mcal {M}_n\) be the \(\mcal {L}\)-structure with domain
\(\{1,\ldots ,n\}\), for every relation symbol \(R\) of \(\mcal {L}\), let \(R^{\mcal {M}_n}=\emptyset \), for every function symbol \(F\) of \(\mcal {L}\), let \(F^{\mcal {M}_n}\) be the function defined by \(F^\mcal {M}(m_1,\ldots
,m_l):=m_1\), and for every constant symbol \(c\) of \(\mcal {L}\), let \(c^{\mcal {M}_n}=1\). The class of \(\mcal {L}\)-structures is axiomatised by the empty set of \(\mcal {L}\)-sentences. So by <a
href="Application-Compactness-Theorem-Extension-Constants.html#finiteunbounded">5.3</a>, the set of finite \(\mcal {L}\)-structures is not axiomatisable. This gives a contradiction. Therefore \(\phi \) does not axiomatise the class of
infinite \(\mcal {L}\)-structures. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<b>Warning</b>: For some languages \(\mcal {L}\), there exist consistent \(\mcal {L}\)-sentences which only have infinite models. Such sentences often use the fact that every injective function from a finite set to itself is surjective (or that every surjective
function from a finite set to itself is injective). See Exercise Sheet \(8\).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-323"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">5.7</span></span>. </span> The previous proposition is part of a general pattern of results. Let \(X\) be a class of \(\mcal
{L}\)-structures and let \(Y\) be the class of all \(\mcal {L}\)-structures not in \(X\). If \(X\) is axiomatised by a single \(\mcal {L}\)-sentence \(\phi \) then \(Y\) is axiomatised by \(\neg \phi \). So to show that \(X\) is not axiomatised by
a single sentence, we can show that \(Y\) is axiomatisable. For reasons beyond the scope of this course, this will always work.
</p>

</li>

</ul>

</div>

<p>
Here is a simple consequence of the Compactness Theorem that doesn’t involve not being able to axiomatise classes of structures with finite unbounded size.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-324"></a>
<span class="amsthmnameplain">Exercise</span><span class="amsthmnumberplain"> <span class="textup">5.8</span></span>. </span> Let \(\mcal {L}_{gp}:=\langle \cdot , (-)^{-1}, e \rangle \) be the language of groups. We say a
group \(G\) is <b>torsion</b> if all its elements have finite order. You should know from \(1\)st year group theory that all finite groups are torsion. There exist (interesting) infinite torsion groups. For instance, let \(U(\mathbb {C})\) be the
multiplicative group of complex roots \(1\), i.e., the set of \(z\in \C \) such that \(z^n=1\) for some \(n\in \N \). Show that the class of torsion groups is not axiomatisable.
</p>

</li>

</ul>

</div>

<p>
For more sophisticated applications of the Compactness Theorem, we need to use the method of “extensions by constants”. For completeness, I give the general definition of the extension of a language.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-325"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5.9</span></span>. </span> Let \(\mcal {L}:=\langle \mcal {R},\mcal {F},\mcal {C}\rangle \) and \(\mcal {L}^+:=\langle
\mcal {R}^+,\mcal {F}^+,\mcal {C}^+\rangle \) be languages where \(\mcal {R}, \mcal {R}^+\) are relation symbols, \(\mcal {F},\mcal {F}^+\) are function symbols and \(\mcal {C}, \mcal {C}^+\) are constant symbols.
</p>

<p>
We say that \(\mcal {L}^+\) is an <b>extension</b> of \(\mcal {L}\) and \(\mcal {L}\) is a <b>sublanguage</b> of \(\mcal {L}^+\) if \(\mcal {R}\subseteq \mcal {R}^+\), \(\mcal {F}\subseteq \mcal {F}^+\) and \(\mcal
{C}\subseteq \mcal {C}^+\) (note, any relation/function symbol of both \(\mcal {L}\) and \(\mcal {L}^+\) should have the same arity).
</p>

<p>
If \(\mcal {L}^+\) is an extension of \(\mcal {L}\) with \(\mcal {R}^+=\mcal {R}\) and \(\mcal {F}^+=\mcal {F}\) then we call \(\mcal {L}^+\) an <b>extension by constants</b> of \(\mcal {L}\). In this case we write \(\mcal
{L}^+=\mcal {L}(\mcal {D})\) where \(\mcal {D}=\mcal {C}^+\backslash \mcal {C}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-326"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5.10</span></span>. </span> If \(\mcal {M} ^+\) is an \(\mcal {L} ^+\)-structure then there is a unique \(\mcal {L}\)-structure
\(\mcal {M}^+ \) with the same domain as \(\mcal {M}\) and with \(R^\mcal {M} =R^{\mcal {M} ^+}\) for all relation symbols \(R\) of \(\mcal {L}\), \(F^\mcal {M} =F^{\mcal {M} ^+}\) for all function symbol \(F\) of \(\mcal {L}\) and
\(c^\mcal {M} =c^{\mcal {M} ^+}\) for all constant symbol \(c\) of \(\mcal {L}\). The structure \(\mcal {M} \) is called the <b>restriction of \(\mcal {M}^+\) to \(\mcal {L}\)</b> and \(\mcal {M} ^+\) is called an <b>expansion of
\(\mcal {M} \) to \(\mcal {L} ^+\)</b>. The structure \(\mcal {M} \) is also called a <b>reduct of \(\mcal {M}^+\)</b>.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-327"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">5.11</span></span>. </span> Let \(\mcal {L}^+\) be an extension of \(\mcal {L}\). All \(\mcal {L}\)-terms (resp. \(\mcal
{L}\)-formulas) are \(\mcal {L}^+\)-terms (resp. \(\mcal {L}^+\)-formulas) in which only elements of the alphabet of \(\mcal {L}\) occur.
</p>

</li>

</ul>

</div>

<p>
This proposition could be proved by induction on the complexity of terms and formulas.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-328"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.12</span></span>. </span> Let \(\mcal {L} ^+\) be an extension of the language \(\mcal {L} \). If \(\mcal {M} \) is the
restriction of the \(\mcal {L} ^+\)-structure \(\mcal {M} ^+\) to \(\mcal {L}\), \(t\in \tm (\mcal {L}) \), \(\phi \in \Fml (\mcal {L}) \) and \(h:\Vbl \rightarrow M\) where \(M\) is the domain of \(\mcal {M}\) (hence \(h\) is an
assignment of \(\mcal {M} \) and of \(\mcal {M} ^+\)), then
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(t^\mcal {M} [h]=t^{\mcal {M} ^+}[h]\) and
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> \(\mcal {M} \models \phi [h]\iff \mcal {M} ^+\models \phi [h].\)
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
We now give some examples of using extensions by constants in applications of the Compactness Theorem.
</p>

<p>
For our first applications we need an important definition.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-329"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5.13</span></span>. </span> Let \(\mcal {L}\) be a language and let \(\mcal {M}_1,\mcal {M}_2\) be \(\mcal {L}\)-structures.
We say that \(\mcal {M}_1\) and \(\mcal {M}_2\) are <b>elementary equivalent</b> and write \(\mcal {M}_1\equiv \mcal {M}_2\) if for all \(\mcal {L}\)-sentences \(\phi \), \(\mcal {M}_1\models \phi \) if and only if \(\mcal
{M}_2\models \phi \).
</p>

</li>

</ul>

</div>

<p>
This is a very weak version of the Upwards Lo&#x0308;wenheim-Skolem Theorem which will be covered in the 4th year material.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-330"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">5.14</span></span>. </span> Let \(\mcal {L}\) be a language and \(\mcal {M}\) be an infinite \(\mcal {L}\)-structure. For all
cardinalities \(\kappa \), there is an \(\mcal {L}\)-structure \(\mcal {M}&apos;\) such that the domain of \(\mcal {M}&apos;\) has cardinality greater than \(\kappa \) and \(\mcal {M}\equiv \mcal {M}&apos;\).
</p>

<p>
<b>Alternative formulation:</b> Let \(\mcal {L}\) be a language and \(\mcal {M}\) be an infinite \(\mcal {L}\)-structure. For all sets \(\kappa \), there is an \(\mcal {L}\)-structure \(\mcal {M}&apos;\) such that the domain of \(\mcal
{M}&apos;\) has size greater than \(\kappa \) and \(\mcal {M}\equiv \mcal {M}&apos;\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-331"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Let \(\mcal {L}^+\) be an extension of \(\mcal {L}\) with a constant symbol \(c_i\) for every \(i\in \kappa \). Let \(\Sigma \) be the set of \(\mcal
{L}\)-sentences satisfied by \(\mcal {M}\). We show that
</p>

<p>
\[\Sigma \cup \{c_i\neq c_j \st i\neq j\}\]
</p>

<p>
has a model.
</p>

<p>
For each \(X\subseteq \kappa \), define \(\mcal {M}_X\) to be an expansion of \(\mcal {M}\) to an \(\mcal {L}^+\)-structure by picking \(c_i^{\mcal {M}_X}\in \mcal {M}\) so that \(c_i^{\mcal {M}_X}\neq c_j^{\mcal {M}_X}\) for all
\(i,j\in X\) with \(i\neq j\) and picking \(c_i^{\mcal {M}_X}\in \mcal {M}\) for \(i\in \kappa \backslash X\) arbitrarily.
</p>

<p>
Then \(\mcal {M}_X\) is a model of
</p>

<p>
\[\Sigma \cup \{c_i\neq c_j \st i,j\in X \text { and } i\neq j\}.\]
</p>

<p>
It follows that every finite subset of \(\Sigma \cup \{c_i\neq c_j \st i\neq j\}\) has a model. So, by the Compactness Theorem \(\Sigma \cup \{c_i\neq c_j \st i\neq j\}\) has a model \(\mcal {M}_\kappa \). Since \(c_i^{\mcal
{M}_\kappa }\neq c_j^{\mcal {M}_\kappa }\) for all \(i\neq j\) in \(\kappa \), \(\mcal {M}_\kappa \) has size at least \(\kappa \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-332"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5.15</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> A set \(X\) together with a binary relation \(\leq \) is a total order if for all \(a,b,c\in X\),
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(a\leq b\) and \(b\leq c\) implies \(a\leq c\);
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> \(a\leq a\);
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> \(a\leq b\) and \(b\leq a\) implies \(a=b\); and
</p>


</li>
<li>


<p>
<span class="listmarker">(iv)</span> \(a\leq b\) or \(b\leq a\).
</p>
</li>
</ul>
</li>
<li>


<p>
<span class="listmarker">2.</span> An <b>ordered ring</b> is a ring \(R\) together with a total order \(\leq \) which satisfies the following properties:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> For all \(a,b,c\in R\), if \(b\leq c\) then \(a+b\leq a+c\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> For all \(a,b,c\in R\), if \(0\leq a\) and \(b\leq c\) then \(ab\leq ac\).
</p>
</li>
</ul>
</li>
<li>


<p>
<span class="listmarker">3.</span> The language of ordered rings is \(\mcal {L}_{\text {o-ring}}:=\langle \geq , +,\cdot ,-,0,1\rangle \). where \(\geq \) is a binary relation symbol, \(+\) and \(\cdot \) are binary function
symbols, \(-\) is a unary function symbol and \(0\) and \(1\) are constant symbols.
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
Note that the class of ordered rings is axiomatisable in \(\mcal {L}_{\text {o-ring}}\).
</p>

<p>
You already know lots of examples of ordered rings. For example, \(\Z \), \(\R \) and \(\Q \) are all ordered rings when equipped with their usual order. Any ordered ring can be viewed as an \(\mcal {L}_{\text {o-ring}}\)-structure in the obvious way. If
\(R\) is an ordered ring then for all \(n\in \N \),
</p>

<p>
\[\underbrace {1+\ldots +1}_{\text {n times}}\neq 0.\]
</p>

<p>
A (positive) <b>infinitesimal element</b> of an ordered ring \(R\) is an element \(\epsilon \in R\) such that for all \(n\in \N \), \(0&lt;n\epsilon \leq 1\). If \(R\) is a field then we may rewrite this as \(0&lt;\epsilon \leq 1/n\) for all \(n\in
\N \).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-333"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">5.16</span></span>. </span> Let \(\mcal {L}_{\text {o-ring}}:=\langle \geq , +,\cdot ,-,0,1\rangle \). There exists an
ordered ring which has infinitesimal elements and is elementary equivalent to \(\R \) as an ordered ring.
</p>

<p>
Let \(\mcal {L}_{\text {o-ring}}(\epsilon )\) be the extension of \(\mcal {L}_{\text {o-ring}}\) by the constant symbol \(\epsilon \). We want to write down a \(\mcal {L}_{\text {o-ring}}(\epsilon )\)-sentence which, for \(n\in
\N \), says that \(0&lt;n\epsilon \leq 1\). Technically “\(n\)” is not part of our language. For each \(n\in \N \), we define an \(\mcal {L}_{\text {o-ring}}\)-term \(t_n\) by induction. Let \(t_1:=1\). For all \(n\in \N \), let
\(t_{n+1}:=(t_n+1)\). Note that this means that for all \(\mcal {L}_{\text {o-ring}}\)-structures \(\mcal {A}\),
</p>

<p>
\[t_n^{\mcal {A}}=\underbrace {1^{\mcal {A}}+\ldots +1^{\mcal {A}}}_{n\text { times}}.\]
</p>

<p>
For each \(n\in \N \), let \(\phi _n\) be the \(\mcal {L}_{\text {o-ring}}(\epsilon )\)-sentence
</p>

<p>
\[0&lt; \epsilon \wedge t_n\cdot \epsilon \leq 1.             \]
</p>

<p>
Let \(T\) be the set of \(\mcal {L}_{\text {o-ring}}\)-sentences satisfied by \(\R \). We will show that the set of \(\mcal {L}_{\text {o-ring}}(\epsilon )\)-sentences \(T\cup \{\phi _n\st n\in \N \}\) has a model. Let \(X\subseteq
T\cup \{\phi _n\st n\in \N \}\) be finite. Let \(m\in \N \) be greatest such that \(\phi _m\in X\). Let \(\mcal {M}_X\) be the \(\mcal {L}_{\text {o-ring}}(\epsilon )\)-structure which is an expansion of \(\R \) as an \(\mcal
{L}_{\text {o-ring}}\)-structure to an \(\mcal {L}_{\text {o-ring}}(\epsilon )\)-structure by setting \(\epsilon ^{\mcal {M}_X}:=1/(m+1)\). Then \(t_m\cdot \epsilon ^{\mcal {M}_X}=m/m+1\) and \(0&lt;m/m+1\leq 1\). So \(\mcal
{M}_X\) is a model of \(X\). Thus, by the Compactness Theorem, there exists an \(\mcal {L}_{\text {o-ring}}(\epsilon )\)-structure \(\mcal {M}\) which satisfies \(T\cup \{\phi _n\st n\in \N \}\). Since \(\mcal {M}\models T\), the
\(\mcal {L}\)-reduct of \(\mcal {M}\) is elementary equivalent to \(\R \) as an ordered ring. For all \(n\in \N \), \(\mcal {M}\models \phi _n\). Therefore \(\epsilon ^\mcal {M}\) is an infinitesimal. Therefore the \(\mcal {L}\)-reduct of
\(\mcal {M}\) has the required properties.
</p>

</li>

</ul>

</div>

<p>
The next example we give is also to ordered structures. This time we use a strict order.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-334"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">5.17</span></span>. </span> Let \(\mcal {L}:=\langle &lt;\rangle \) where \(&lt;\) is a binary relation symbol. For each
\(n\in \N \), let \(\mcal {A}_n\) be the \(\mcal {L}\)-structure with domain \(\{1,\ldots ,n\}\) with \(&lt;^{\mcal {A}_n}\) defined as the usual strict order on \(\{1,\ldots ,n\}\). Let \(T\) be the set of \(\mcal {L}\)-sentences satisfied
by all \(\mcal {A}_n\). There is an \(\mcal {L}\)-structure \(\mcal {A}\) with domain \(A\) such that \(\mcal {A}\models T\) and for all \(r\in \R \), there exists \(a_r\in A\) such that for all \(r,s\in \R \),
</p>

<p>
\[a_r&lt;a_s \text { if and only if }r&lt;s \text { in } \R \]
</p>

<p>
To show this we extend our language by \(\R \)-many constant symbols. Let \(\mcal {L}_\R :=\langle &lt;, (c_r)_{r\in \R } \rangle \) where \(&lt;\) is the binary relation symbol from \(\mcal {L}\) and \(c_r\) is a constant symbol for
all \(r\in \R \). For each pair of rational numbers \(r,s\), let \(\phi _{r&lt;s}\) be the \(\mcal {L}_\R \)-formula \(c_r&lt;c_s\).
</p>

<p>
For \(X\subseteq \R \), let
</p>

<p>
\[\Sigma _X:=\{\phi _{r&lt;s} \st r,s\in X \text { and } r&lt;s\}\cup \{(\neg \phi _{r&lt;s})\mid r,s\in X \text { and } r \not &lt; s\}.\]
</p>

<p>
We will show that for all finite \(Y\subseteq \R \), \(\Sigma _Y\cup T\) has a model. Let \(Y=\{r_1,\ldots ,r_n\}\) with \(r_1&lt;r_2&lt;\ldots &lt;r_n\). We expand \(\mcal {A}_n\) to an \(\mcal {L}_\R \)- structure \(\mcal
{A}_{n,Y}\) which is a model of \(\Sigma _Y\). For each \(r_i\), let \(c_{r_i}^{\mcal {A}_{n,Y}}\) be \(i\) and for \(r\notin Y\), let \(c_r^{\mcal {A}_{n,Y}}=1\). This means that for all \(r,s\in Y\), \(r&lt;s\) if and only if
\(c_r&lt;^{\mcal {A}_n}c_s\). So \(\mcal {A}_n\), as an \(\mcal {L}_\R \)-structure, is a model of \(\Sigma _Y\). Finally, \(\mcal {A}_{n,Y}\), as an \(\mcal {L}_\R \)-structure, is a model of \(T\) because, by definition of \(T\), \(\mcal
{A}_{n,Y}\) is \(\mcal {A}_n\) as an \(\mcal {L}\)-structure.
</p>

<p>
If \(S\subseteq \Sigma _\R \cup T\) is finite then there exists a finite subset \(Y\subseteq \R \) such that \(S\subseteq \Sigma _Y\cup T\). So, for any such \(S\), \(\mcal {A}_{n,Y}\) is a model of \(S\). Therefore, by the Compactness
Theorem, \(\Sigma _\R \cup T\) has a model \(\mcal {A}\). Since \(\mcal {A}\models \Sigma _{\R }\),
</p>

<p>
\[c_r^{\mcal {A}}&lt;^{\mcal {A}}c_s^{\mcal {A}} \text { if and only if } r&lt;s.\]
</p>

<p>
So setting \(a_r:=c_r^\mcal {A}\) and viewing \(\mcal {A}\) as an \(\mcal {L}\)-structure, gives a model of \(T\) with the required properties.
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Universal-Algebra-Substructures-Homomorphisms.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Universal Algebra: Substructures and Homomorphisms</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-335"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Universal Algebra: Substructures and Homomorphisms ......
-->
<h4 id="autosec-336"><span class="sectionnumber">6&#x2003;</span>Universal Algebra: Substructures and Homomorphisms</h4>
<a id="Logic-autopage-336"></a>
<a id="Logic-autofile-13"></a>

<a id="unialg"></a>

<p>
The material in this section will not appear on the 3rd year exam. However, 4th years need to know what a substructure is and what an isomorphism of \(\mcal {L}\)-structures is.
</p>

<p>
In this section we give a general definitions of substructures and homomorphisms for \(\mcal {L}\)-structures. These definitions will mostly match up with ones you already know if we have picked the correct language. Warning: This will not always be the case!
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-337"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.1</span></span>. </span> Let \(\mcal {A},\mcal {B}\) be \(\mcal {L}\)-structures with domains \(A\) and \(B\) respectively.
A <b>map from \(\mcal {A}\) to \(\mcal {B}\)</b> is a function \(f:A\rightarrow B\). We will write \(f:\mcal {A}\rightarrow \mcal {B}\) instead of \(f:A\rightarrow B\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-338"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.2</span></span>. </span> Let \(\mcal {L}\) be a language and let \(\mcal {A},\mcal {B}\) be \(\mcal {L}\)-structures with
domains \(A\) and \(B\) respectively. A map \(g:\mcal {A}\rightarrow \mcal {B}\) is a <b>homomorphism of \(\mcal {L}\)-structures</b> if
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> for all relation symbols \(R\) of \(\mcal {L}\) of arity \(n\) and elements \(a_1,\ldots ,a_n\), \((a_1,\ldots ,a_n)\in R^{\mcal {A}}\) implies \((g(a_1),\ldots ,g(a_n))\in R^{\mcal {B}}\);
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> for all function symbols \(F\) of \(\mcal {L}\) of arity \(n\) and elements \(a_1,\ldots ,a_n\),
</p>
<p>
\[g(F^{\mcal {A}}(a_1,\ldots ,a_n))=F^{\mcal {B}}(g(a_1),\ldots ,g(a_n));\]
</p>
<p>
and
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> for all constant symbols \(c\) of \(\mcal {L}\), \(g(c^{\mcal {A}})=c^{\mcal {B}}\).
</p>
</li>
</ul>

<p>
A homomorphism \(g:\mcal {A}\rightarrow \mcal {B}\) is an <b>embedding</b> if \(g\) is injective and for all relation symbols \(R\) of arity \(n\),
</p>

<p>
\[(a_1,\ldots ,a_n)\in R^{\mcal {A}} \text { if and only if }(g(a_1),\ldots ,g(a_n))\in R^{\mcal {B}}.\]
</p>

<p>
An embedding \(g:\mcal {A}\rightarrow \mcal {B}\) is an <b>isomorphism</b> if it is bijective.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-339"></a>
<span class="amsthmnameplain">Examples</span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\mcal {L}_\emptyset \) be the empty language. Any function \(f:A\rightarrow B\) where \(A\) and \(B\) are the domains of \(\mcal {L}_\emptyset \)-structures \(\mcal {A}\) and \(\mcal {B}\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> Let \(\mcal {L}_{\textrm {gp}}:=\langle \cdot ,(-)^{-1},e\rangle \) be the language of groups. If \(\mcal {A}\) and \(\mcal {B}\) are \(\mcal {L}_{\textrm {gp}}\)-structures which are groups
then an \(\mcal {L}_{\textrm {gp}}\)-homomorphism \(g:\mcal {A}\rightarrow \mcal {B}\) is just a group homomorphism in the usual sense. Note that this requires a proof and the same statement is true if we instead consider groups in the
language with just the binary operation “\(\cdot \)”.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-340"></a>
<span class="amsthmnameplain">Remark</span>. </span> A homomorphism \(g:\mcal {A}\rightarrow \mcal {B}\) of \(\mcal {L}\)-structures is an isomorphism if and only if there is a homomorphism \(f:\mcal {B}\rightarrow \mcal
{A}\) such that \(fg=\textrm {Id}_{\mcal {A}}\) and \(gf=\textrm {Id}_\mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-341"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.3</span></span>. </span>
</p>

<p>
Let \(\mcal {L}\) be a language and let \(\mcal {A},\mcal {B}\) be \(\mcal {L}\)-structures with domains \(A\) and \(B\) respectively. If \(A\subseteq B\) and the inclusion map is an embedding of \(\mcal {L}\)-structures then we call
\(\mcal {A}\) a substructure of \(\mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-342"></a>
<span class="amsthmnameplain">Examples</span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> Let \(\mcal {L}_\emptyset \) be the empty language. Let \(\mcal {B}\) be an \(\mcal {L}_\emptyset \)-structure. Then any non-empty subset \(A\) is the domain of a substructure of \(\mcal {B}\).
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> Let \(\mcal {L}_{\textrm {gp}}\) be the language of groups. If \(\mcal {B}\) is an \(\mcal {L}_{\textrm {gp}}\)-structure which is a group then the \(\mcal {L}_{\textrm {gp}}\)-substructures of
\(\mcal {B}\) are exactly the subgroups of \(\mcal {B}\).
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> Let \(\mcal {L}:=\langle \cdot \rangle \). If \(\mcal {B}\) is an \(\mcal {L}\)-structure which is a group under \(\cdot ^{\mcal {B}}\) then the \(\mcal {L}\)-substructures of \(\mcal {B}\) are not
necessarily subgroups.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-343"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">6.4</span></span>. </span> Let \(\mcal {L}\) be a language and let \(\mcal {A},\mcal {B}\) be \(\mcal {L}\)-structures with
domains \(A\) and \(B\) respectively. Suppose that \(A\subseteq B\). Then \(\mcal {A}\) is a <b>substructure</b> of \(\mcal {B}\) if and only if the following conditions hold:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> For all relation symbols \(R\) of \(\mcal {L}\) of arity \(n\) and \(a_1,\ldots ,a_n\in A\), \((a_1,\ldots ,a_n)\in R^{\mcal {A}}\) if and only if \((a_1,\ldots ,a_n)\in R^{\mcal {B}}\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> For all function symbols \(F\) of \(\mcal {L}\) of arity \(n\) and \(a_1,\ldots ,a_n\in A\), \(F^{\mcal {A}}(a_1,\ldots ,a_n)=F^{\mcal {B}}(a_1,\ldots ,a_n)\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> For all constant symbols \(c\) of \(\mcal {L}\), \(c^{\mcal {A}}=c^{\mcal {B}}\).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
This allows the following definition.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-344"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6.5</span></span>. </span> Let \(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\). Let \(A\subseteq M\) be such
that for all function symbols \(F\) of \(\mcal {L}\) and \(a_1,\ldots ,a_n\in A\), \(F^{\mcal {M}}(a,\ldots ,a_n)\in A\) and for all constant symbols \(c\) of \(\mcal {L}\), \(c^{\mcal {M}}\in A\). Then the <b>substructure of \(\mcal
{M}\) induced on \(A\)</b> is the unique substructure \(\mcal {A}\) of \(\mcal {M}\) with domain \(A\). It follows from the definition of substructure that
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(R^{\mcal {A}}=R^{\mcal {M}}\cap A^n\) for all relation symbols \(R\) of arity \(n\);
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> \(F^{\mcal {A}}(a_1,\ldots ,a_n)=F^{\mcal {M}}(a_1,\ldots ,a_n)\) for all functions symbols \(F\) of arity \(n\); and
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> \(c^{\mcal {A}}=c^{\mcal {M}}\) for all constant symbols \(c\).
</p>
</li>
</ul>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Further-Model-Theory-4th-year-material.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Further Model Theory (4th year material)</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-345"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... section Further Model Theory (4th year material) ......
-->
<h4 id="autosec-346"><span class="sectionnumber">7&#x2003;</span>Further Model Theory (4th year material)</h4>
<a id="Logic-autopage-346"></a>
<a id="Logic-autofile-14"></a>

<p>
I will just write skeleton notes for this section with reference to books. This is possible because the material is no longer so sensitive to presentation. On the other hand, do let me know if you don’t understand something in one of the books, in particular, if you
don’t understand some notation or terminology. I very strongly suggest you try the exercises on Sheet 10 related to this section.
</p>
<!--
...... subsection Definable Sets ......
-->
<h5 id="autosec-347"><span class="sectionnumber">7.1&#x2003;</span>Definable Sets</h5>
<a id="Logic-autopage-347"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-348"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.1</span></span>. </span> Let \(\mcal {L}\) be a language and \(\mcal {A}\) an \(\mcal {L}\)-structure with domain \(A\).
We say a subset \(S\subseteq A^n\) for some \(n\in \N \) is <b>definable</b> if there exists an \(\mcal {L}\)-formula \(\phi (v_1,\ldots ,v_n)\) such that for all \((a_1,\ldots ,a_n)\in A^n\)
</p>

<p>
\[\mcal {A}\models \phi [a_1,\ldots ,a_n] \text { if and only if } (a_1,\ldots ,a_n)\in S.\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-349"></a>
<span class="amsthmnameplain">Examples</span><span class="amsthmnumberplain"> <span class="textup">7.2</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> If \(\mcal {L}_{\textrm {gp}}\) is the language of groups and \(\mcal {G}\) is an \(\mcal {L}_{\textrm {gp}}\)-structure which is a group then the centre \(\textrm {Z}(\mcal {G})\) of \(\mcal {G}\)
is defined by the formula \(\forall v_2 \, v_1\cdot v_2=v_2\cdot v_1\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span>
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-350"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.3</span></span>. </span> Let \(\mcal {L}\) be a language and \(\mcal {A},\mcal {B}\) an \(\mcal {L}\)-structures with
domain \(A\) and \(B\) respectively. An <b>embedding</b> of \(\mcal {A}\) in \(\mcal {B}\) is an injective function \(\alpha :A\rightarrow B\) such that
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> for all relation symbols \(R\) of \(\mcal {L}\) and \((a_1,\ldots ,a_n)\in A^{n}\),
</p>
<p>
\[(a_1,\ldots ,a_n)\in R^{\mcal {A}}\text { if and only if }(\alpha (a_1),\ldots ,\alpha (a_n))\in R^{\mcal {B}};\]
</p>
</li>
<li>


<p>
<span class="listmarker">(ii)</span> for all function symbols \(F\) of \(\mcal {L}\) and \((a_1,\ldots ,a_n)\in A^{n}\)
</p>
<p>
\[\alpha (F^{\mcal {A}}(a_1,\ldots ,a_n))=F^\mcal {B}(\alpha (a_1),\ldots ,\alpha (a_n));\]
</p>
<p>
and
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> for all constant symbols \(c\) of \(\mcal {L}\), \(\alpha (c^{\mcal {A}})=c^{\mcal {B}}\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-351"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.4</span></span>. </span> Let \(\mcal {L}\) be a language and \(\mcal {A}\) an \(\mcal {L}\)-structure. An
<b>automorphism</b> of \(\mcal {A}\) is a bijective embedding \(\alpha :\mcal {A}\rightarrow \mcal {A}\).
</p>

</li>

</ul>

</div>

<p>
The next theorem shows that “automorphisms preserve definable sets”.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-352"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.5</span></span>. </span> Let \(\mcal {L}\) be a language and \(\mcal {A}\) an \(\mcal {L}\)-structure. Let \(\alpha :\mcal
{A}\rightarrow \mcal {A}\) be an automorphism. For all \(\mcal {L}\)-formulas \(\phi (x_1,\ldots ,x_n)\) and \((a_1,\ldots ,a_n)\in A^n\),
</p>

<p>
\[\mcal {A}\models \phi [a_1,\ldots ,a_n]\text { if and only if }\mcal {A}\models \phi [\alpha (a_1),\ldots ,\alpha (a_n)].\]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
For examples using this theorem to show that a set is not definable in an \(\mcal {L}\)-structure see Section 4.2 of “An invitation to model theory” by Jonathan Kirby.
</p>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Elementary-Substructures.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Elementary Substructures</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-353"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Elementary Substructures ......
-->
<h5 id="autosec-354"><span class="sectionnumber">7.2&#x2003;</span>Elementary Substructures</h5>
<a id="Logic-autopage-354"></a>
<a id="Logic-autofile-15"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-355"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.6</span></span>. </span> A map \(f:\mcal {A}\rightarrow \mcal {B}\) is an <b>elementary embedding</b> if for all
\(\mcal {L}\)-formulas \(\phi (x_1,\ldots ,x_n)\) and \(a_1,\ldots ,a_n\in A\), \(\mcal {A}\models \phi [a_1,\ldots ,a_n]\) if and only if \(\mcal {B}\models \phi [f(a_1),\ldots ,f(a_n)]\).
</p>

<p>
If \(A\subseteq B\) and the inclusion map is an elementary embedding then we call \(\mcal {A}\) an <b>elementary substructure</b> of \(\mcal {B}\) and \(\mcal {B}\) an <b>elementary extension</b> of \(\mcal {A}\). We write
\(\mcal {A}\preceq \mcal {B}\) to mean \(\mcal {A}\) is an elementary substructure of \(\mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-356"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">7.7</span></span>. </span> If \(\mcal {A}\) is an elementary substructure of \(\mcal {B}\) then \(\mcal {A}\equiv \mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-357"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">7.8</span></span>. </span> Isomorphisms are elementary embeddings. In particular, isomorphic structures are elementary
equivalent.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-358"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This is proved by induction on the complexity of formulas. Note this was previously stated for automorphisms. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-359"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.9</span></span>. </span> If \(\mcal {A}\) is an elementary substructure of \(\mcal {B}\) then \(\mcal {A}\) is a substructure of
\(\mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-360"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This is exercise \(5\) of sheet 10. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-361"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.10</span></span><span class="amsthmnoteplain"> (Tarski-Vaught Test)</span>. </span> Let \(\mcal {M}\) be an \(\mcal
{L}\)-structure with domain \(M\) and let \(A\subseteq M\). The following are equivalent:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(A\) is the domain of an elementary substructure of \(\mcal {M}\). In this situation we will often say \(A\) is an elementary substructure of \(\mcal {M}\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> For every \(\mcal {L}\)-formula \(\phi (x,y_1,\ldots ,y_n)\) and \(a_1,\ldots ,a_n\in A\), if \(\mcal {M}\models (\exists x \phi )[a_1,\ldots ,a_n]\) then there is some \(b\in A\) such that
\(\mcal {M}\models \phi [b,a_1,\ldots ,a_n]\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-362"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (i)\(\Rightarrow \)(ii) Suppose that \(a_1,\ldots ,a_n\in A\) and \(\mcal {M}\models (\exists x\phi )[a_1,\ldots ,a_n]\). Then by (i), \(\mcal
{A}\models (\exists x\phi )[a_1,\ldots ,a_n]\). By Tarski’s Truth Definition, this implies there exists \(b\in A\) such that \(\mcal {A}\models \phi [b,a_1,\ldots ,a_n]\) as required.
</p>

<p>
(ii)\(\Rightarrow \)(i) The first thing we need to show is that \(A\) is the domain of a substructure. Let \(c\) be a constant symbol of \(\mcal {L}\) and take \(\phi \) to be the formula \(c=v_1\). Then \(\mcal {M}\models \exists v_1\,
\phi \). So, by (ii), \(\mcal {M}\models \phi [b]\) for some \(b\in \mcal {A}\). Therefore \(c^{\mcal {M}}=b\). So \(c^{\mcal {M}}\in A\). Now suppose that \(F\) is an \(n\)-ary function symbol and \(a_1,\ldots ,a_n\in A\). Let
\(\phi (x,y_1,\ldots ,y_n)\) be the formula, \(F(y_1,\ldots ,y_n)=x\). Then \(\mcal {M}\models (\exists x\phi )[a_1,\ldots ,a_n]\). So, by \((ii)\), \(\mcal {A}\models \phi [b,a_1,\ldots ,a_n]\) for some \(b\in A\). Therefore
\(F^{\mcal {M}}(a_1,\ldots ,a_n)=b\). Thus \(A\) is the domain of a substructure of \(\mcal {M}\).
</p>

<p>
We now need to show that this substructure is elementary. We show, by induction on the complexity of the \(\mcal {L}\)-formula \(\phi (y_1,\ldots ,y_n)\), that for all \(a_1,\ldots , a_n\in A\),
</p>

<p>
\[\mcal {M}\models \phi [a_1,\ldots ,a_n] \text { if and only if }\mcal {A}\models \phi [a_1,\ldots ,a_n].\tag {$\dagger $}\]
</p>

<p>
Suppose \(\phi \) is complexity \(0\). The case where \(\phi \) is \(\bot \) is trivial. Suppose \(\phi \) is of the form \(t_1=t_2\) where \(t_1\) and \(t_2\) are terms. It follows by induction on the complexity of terms, just using the fact that
\(\mcal {A}\) is a substructure of \(\mcal {M}\), that if \(h\) is a valuation with \(h(y_i):=a_i\) and \(h(z)\in A\) for all variables \(z\in \Vbl \) that \(t_1^\mcal {M}[h]=t_2^\mcal {M}[h]\) if and only if \(t_1^\mcal {A}[h]=t_2^\mcal
{A}[h]\). Thus \(\mcal {M}\models t_1=t_2[a_1,\ldots ,a_n]\) if and only if \(\mcal {A}\models t_1=t_2[a_1,\ldots ,a_n]\). The case of atomic formulas of the form \(R(t_1,\ldots ,t_n)\) is similar.
</p>

<p>
We now prove the inductive step. If the equivalence holds for \(\phi _1\) and \(\phi _2\) then it is easy to show that the equivalence \((\dagger )\) holds for \((\phi _1\rightarrow \phi _2)\). This implies that if the equivalence \((\dagger
)\) holds for \(\phi \) then it holds for \(\neg \phi \). It’s easy to check that for any formula \(\phi \), \(\neg \exists x\, \neg \phi \equiv \forall x\, \phi \). Thus in order to show that the equivalence \((\dagger )\) is true of
\(\forall x\,\phi \), we just need to show it is true for \(\neg \exists x\, \neg \phi \equiv \forall x\, \phi \).
</p>

<p>
Suppose that \((\dagger )\) holds for \(\phi (x,y_1,\ldots ,y_n)\). By the discussion above, \((\dagger )\) holds of \(\neg \phi \). Suppose \(\mcal {M}\models (\exists x\neg \phi )[a_1,\ldots ,a_n]\) for some \(a_1,\ldots
,a_n\in A\). Then, by (ii), \(\mcal {M}\models \neg \phi [b,a_1,\ldots ,a_n]\) for some \(b\in A\). Since \((\dagger )\) is true for \(\neg \phi \), \(\mcal {A}\models \neg \phi [b,a_1,\ldots ,a_n]\). Thus, by Tarski’s Truth
Definition, \(\mcal {A}\models (\exists x \neg \phi )[a_1,\ldots ,a_n]\). Thus the forward direction of \((\dagger )\) is true for \(\exists x \neg \phi \). Now suppose that \(\mcal {A}\models \exists x \neg \phi [a_1,\ldots
,a_n]\) for \(a_1,\ldots ,a_n\in A\). By Tarski’s Truth Definition, there exists \(b\in A\) such that \(\mcal {A}\models \neg \phi [b,a_1,\ldots ,a_n]\). So, by \((\dagger )\), \(\mcal {M}\models \neg \phi [b,a_1,\ldots ,a_n]\).
So, applying Tarski’s Truth Definition again, we get that \(\mcal {M}\models (\exists x\neg \phi )[a_1,\ldots ,a_n]\). Therefore, \((\dagger )\) holds of \((\exists x\neg \phi )\). But then, by the discussion above, \((\dagger )\)
holds for \(\neg \exists x \neg \phi \). Hence \((\dagger )\) holds for \(\forall x \,\phi \).
</p>

<p>
Thus, by induction on complexity of formulas, \((\dagger )\) holds for all formulas \(\phi \). This implies (i). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Downwards-Lowenheim-Skolem-Theorem.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Downwards Lowenheim-Skolem Theorem</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-363"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Downwards Lowenheim-Skolem Theorem ......
-->
<h5 id="autosec-364"><span class="sectionnumber">7.3&#x2003;</span>Downwards Lo&#x0308;wenheim-Skolem Theorem</h5>
<a id="Logic-autopage-364"></a>
<a id="Logic-autofile-16"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-365"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.11</span></span>. </span> The <b>cardinality of a language</b> \(\mcal {L}\), written \(\textrm {card}(\mcal {L})\), is
the cardinality of \(\mcal {R}\cup \mcal {F}\cup \mcal {C}\) where \(\mcal {R}\) is the set of relation symbols of \(\mcal {L}\), \(\mcal {F}\) is the set of function symbols of \(\mcal {L}\) and \(\mcal {C}\) is the set of constant symbols
of \(\mcal {L}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-366"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.12</span></span><span class="amsthmnoteplain"> (The Downwards Lo&#x0308;wenheim-Skolem Theorem)</span>. </span> Let
\(\mcal {M}\) be an \(\mcal {L}\)-structure with domain \(M\) and let \(A\subseteq M\). Then there is an elementary substructure \(\mcal {N} \) with domain \(N\) of \(\mcal {M} \) such that \(A\subseteq N\) and \(\textrm {card} (\mcal
{N} )\leq \max \{\aleph _0,\textrm {card} (A),\textrm {card} (\mcal {L})\}\).
</p>

</li>

</ul>

</div>

<p>
For more details see “An invitation to Model Theory” section 12.3.
</p>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Upwards-Lowenheim-Skolem-Theorem.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Upwards Lowenheim-Skolem Theorem</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-367"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Upwards Lowenheim-Skolem Theorem ......
-->
<h5 id="autosec-368"><span class="sectionnumber">7.4&#x2003;</span>Upwards Lo&#x0308;wenheim-Skolem Theorem</h5>
<a id="Logic-autopage-368"></a>
<a id="Logic-autofile-17"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-369"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.13</span></span><span class="amsthmnoteplain"> (The Upwards Lo&#x0308;wenheim-Skolem Theorem)</span>. </span> Let
\(\mcal {M} \) be an infinite \(\mcal {L}\)-structure and let \(\kappa \) be a cardinal of size greater than or equal to \(\textrm {card}(\mcal {M})\) and \(\textrm {card}(\mcal {L})\). Then there is an elementary extension \(\mcal
{N}\succeq \mcal {M}\) of cardinality \(\kappa \).
</p>

</li>

</ul>

</div>

<p>
For more details see “An invitation to Model Theory” section 13.2.
</p>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Categoricity.html|-->

<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Categoricity</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-370"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Categoricity ......
-->
<h5 id="autosec-371"><span class="sectionnumber">7.5&#x2003;</span>Categoricity</h5>
<a id="Logic-autopage-371"></a>
<a id="Logic-autofile-18"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-372"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.14</span></span>. </span> Recall that an <b>\(\mcal {L}\)-theory</b> is a consistent set of \(\mcal {L}\)-sentences. If \(X\)
is a class of \(\mcal {L}\)-structures then <b>the theory of \(X\)</b> is the set of all \(\mcal {L}\)-sentences satisfied by all \(\mcal {L}\)-structures in \(X\). The \(\mcal {L}\)-theory of a single \(\mcal {L}\)-structure is the set of \(\mcal
{L}\)-sentences satisfied by that \(\mcal {L}\)-structure.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-373"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.15</span></span>. </span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> Let \(\kappa \) be an infinite cardinal. A theory \(T\) is \(\kappa \)-<b>categorical</b> if all models of \(T\) of cardinality \(\kappa \) are isomorphic.
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> A theory \(T\) is <b>categorical</b> if for some infinite cardinal \(\kappa \geq \textrm {card}(\mcal {L})\), all models of \(T\) of cardinality \(\kappa \) are isomorphic.
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-374"></a>
<span class="amsthmnameplain">Example</span>. </span> Let \(\mcal {L}_\emptyset \) be the empty language and let \(T_\emptyset \) be the empty \(\mcal {L}_\emptyset \)-theory. If \(\mcal {A}\) and \(\mcal {B}\) are \(\mcal
{L}_\emptyset \)-structures of the same cardinality then, by definition, there is a bijection \(f:A\rightarrow B\). Then \(f\) is an isomorphism of \(\mcal {L}_\emptyset \)-structures. Therefore \(T_\emptyset \) is \(\kappa \)-categorical for
every infinite cardinal \(\kappa \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-375"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.16</span></span><span class="amsthmnoteplain"> (Categoricity Theorem)</span>. </span> Let \(T\) be a theory without finite
models. If \(T\) is categorical then all models of \(T\) are elementary equivalent. In particular, if \(T\) is categorical and deductively closed (i.e. for all \(\mcal {L}\)-sentences \(\phi \), \(T\proves \phi \) implies \(\phi \in T\)) then \(T\) is
complete.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-376"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose \(T\) is categorical. Let \(\kappa \) be such that \(\kappa \geq \text {card}(\mcal {L})\) and all models of \(T\) of size \(\kappa \) are
isomorphic. Let \(\mcal {M}\) and \(\mcal {N}\) be models of \(T\). By the LS Theorems, any, by assumption infinite, model of \(T\) either has an elementary extension of cardinality \(\kappa \) or an elementary restriction of cardinality
\(\kappa \). Therefore there are models \(\mcal {M}&apos;\) and \(\mcal {N}&apos;\) of cardinality \(\kappa \) such that \(\mcal {M}\equiv \mcal {M}&apos;\) and \(\mcal {N}\equiv \mcal {N}&apos;\). By assumption \(\mcal
{N}&apos;\) is isomorphic to \(\mcal {M}&apos;\) and hence \(\mcal {N}\equiv \mcal {N}&apos;\equiv \mcal {M}&apos;\equiv \mcal {M}\).
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
For important examples of (\(\kappa \)-)categorical theories, see your exercise sheet (and Jonathan Kirby’s book “An Invitation to Model Theory”.)
</p>

<a id="Logic-autofile-last"></a>
</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
