
<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Proofs</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-244"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Proofs ......
-->
<h5 id="autosec-245"><span class="sectionnumber">3.4&#x2003;</span>Proofs</h5>
<a id="Logic-autopage-245"></a>
<a id="Logic-autofile-9"></a>

<p>
I have deliberately chosen a Hilbert style proof system which is as similar as possible to the one we used for Propositional Logic. Like in Propositional Logic we will have a number of axioms and one deduction rule (modus ponens). If you look in books, even
amongst those that use a Hilbert style proof system, you will see a lot of variance particularly amongst what formulas are chosen to be axioms. One fairly unusual choice I have made is to have only one deduction rule whereas many other sources also have a
“generalisation rule”. I have removed the need for this by adding extra axioms.
</p>

<p>
Our first task for this section is to define what a deduction is for predicate logic and hence to define the symbol \(\proves \).
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-246"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.46</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. Each of the following \(\mcal {L}\)-formulas are called
<b>logical axioms</b> (of \(\mcal {L} \)), where \(\phi ,\psi \) and \(\gamma \) are \(\mcal {L} \)-formulas and \(x\) is a variable:
</p>

<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><b>(AxProp)</b></span>
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(a)</span> \(\phi \to (\psi \to \phi )\)
</p>


</li>
<li>


<p>
<span class="listmarker">(b)</span> \((\phi \to (\psi \to \gamma )) \to ((\phi \to \psi ) \to (\phi \to \gamma ))\)
</p>


</li>
<li>


<p>
<span class="listmarker">(c)</span> \(((\lnot \psi )\to (\lnot \phi )) \to ( \phi \to \psi )\)
</p>
</li>
</ul>
</li>
<li>


<p>
<span class="listmarker"><b>(Ax\(\forall \!\rightarrow \))</b></span> \(\forall x(\phi \rightarrow \psi )\ \rightarrow \ ((\forall x \phi ) \ \rightarrow \ (\forall x\psi ))\)
</p>


</li>
<li>


<p>
<span class="listmarker"><b>(AxSub)</b></span> \((\forall x\phi )\ \rightarrow \ \phi (x/t)\), where \(t\in \tm (\mcal {L})\) is substitutable in \(\phi \) for \(x\)
</p>
</li>
<li>


<p>
<span class="listmarker"><b>(AxGen)</b></span> \(\phi \rightarrow \forall x\phi \), where \(x\) is <i>not</i> a free variable of \(\phi \)
</p>
</li>
<li>


<p>
<span class="listmarker"><b>(Ax x=x)</b></span> \(x=x\)
</p>


</li>
<li>


<p>
<span class="listmarker"><b>(AxEq)</b> </span> \(x=y\rightarrow (\phi \rightarrow \phi (x/y))\) where \(y\) is substitutable for \(x\) in \(\phi \).
</p>


</li>
<li>


<p>
<span class="listmarker"><b>(Ax\(\forall \))</b>              </span> Any formula of the form
</p>
<p>
\[\forall x_1\,\ldots \,\forall x_n\ \alpha \]
</p>
<p>
where \(\alpha \) is one of the formulas introduced by the other logical axioms above and \(x_1,...,x_n\) are variables.
</p>
</li>
</ul>

<p>
We call <b>(AxSub)</b> the substitution axiom, <b>(AxEq)</b> the axiom of equality and <b>(AxGen)</b> the generalisation axiom.
</p>

</li>

</ul>

</div>

<p>
I will also refer to these \(\mcal {L}\)-formulas as the axioms for predicate logic. This is a tiny bit dodgy because the axioms are actually different depending on \(\mcal {L}\) because the formulas involved are \(\mcal {L}\)-formulas.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-247"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.47</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas. A
<b>deduction</b> from \(\Sigma \) is a finite tuple \((\phi _1,\phi _2,\ldots ,\phi _n)\) of \(\mcal {L}\)-formulas such that for each \(1\leq k\leq n\) one of the following is true:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> \(\phi _k\) is a logical axiom (of \(\mcal {L}\));
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> \(\phi _k\in \Sigma \); or
</p>


</li>
<li>


<p>
<span class="listmarker">3.</span> there exist \(i,j&lt;k\) such that \(\phi _i\) is \((\phi _j\rightarrow \phi _k)\).
</p>
</li>
</ul>

<p>
We will call a deduction \((\phi _1,\ldots ,\phi _n)\) from \(\Sigma \) with \(\phi _n=\phi \) <b>a deduction of \(\phi \) from \(\Sigma \)</b> and write \(\Sigma \vdash \phi \) to mean there is a deduction of \(\phi \) from
\(\Sigma \).
</p>

</li>

</ul>

</div>

<p>
Note that I copied and pasted this definition from the propositional logic section, swapped “axiom” for logical axiom (of \(\mcal {L}\)), swapped \(t\) for \(\phi \) and \(S\) for \(\Sigma \). We will call the final rule “<b>modus ponens</b>” and sometimes
abbreviate it MP. Exactly as in propositional logic, I will display deductions as a series of numbered lines with a justification of each line on the right hand side. Finally, I will some times say \(\Sigma \) proves \(\phi \) to mean \(\Sigma \proves \phi \).
</p>

<p>
We get the same immediate consequences of the definition of a deduction as we did for propositional logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-248"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.48</span></span>. </span> <a id="deductionrempred"></a> The following are immediate consequences of the definition of a
deduction.
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> If \((\phi _1,\ldots ,\phi _n)\) is a deduction from \(\Sigma \) then so is \((\phi _1,\ldots , \phi _m)\) for all \(m\leq n\). In particular, \(\Sigma \vdash \phi _m\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> If \((\phi _1,\ldots , \phi _n)\) and \((\psi _1,\dots , \psi _m)\) are deductions from \(\Sigma \) then so is their concatenation, that is \((\phi _1,\ldots ,\phi _n,\psi _1,\ldots ,\psi
_m)\).
</p>


</li>
<li>


<p>
<span class="listmarker">(iii)</span> If \(\phi \in \Sigma \) then \(\Sigma \vdash \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(iv)</span> If \(\phi \) is an instance of a logic axiom (of \(\mcal {L}\)) then \(\proves \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(v)</span> If \(\Sigma &apos;\proves \phi \) and \(\Sigma &apos;\subseteq \Sigma \) then \(\Sigma \proves \phi \).
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
I didn’t include the next statement in the propositional logic section but the appropriate version does also hold for propositional logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-249"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.49</span></span><span class="amsthmnoteplain"> (Modus Ponens for proofs)</span>. </span> If \(\Sigma \proves \phi
\rightarrow \psi \) and \(\Sigma \proves \phi \) then \(\Sigma \proves \psi \).
</p>

</li>

</ul>

</div>

<p>
We also get a “Proofs are finite” Theorem for Predicate Logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-250"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.50</span></span><span class="amsthmnoteplain"> (“Proofs are finite”)</span>. </span> Let \(\mcal {L}\) be a (first order)
language. For all \(\Sigma \subseteq \Fml (\mcal {L})\) and \(\phi \in \Fml (\mcal {L})\), the following are equivalent:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(\Sigma \proves \phi \).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> There is a finite subset \(\Sigma &apos;\subseteq \Sigma \) with \(\Sigma &apos;\proves \phi \).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-251"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The audience should tell me how to prove this. It is the same for Propositional Logic where it was an exercise. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-252"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">3.51</span></span>. </span> Replacing propositional variables by \(\mcal {L}\)-formulas in a deduction in propositional logic gives us
a deduction in predicate logic. For instance, we show that \(\vdash (s\rightarrow s)\) for \(s\) a propositional formula. Replacing every instance of \(s\) in the deduction by a formula \(\phi \) in a (first order) language \(\mcal {L}\) give us
a deduction in predicate logic and this shows that \(\vdash (\phi \rightarrow \phi )\)
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-253"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.52</span></span><span class="amsthmnoteplain"> (Deduction Theorem)</span>. </span> Let \(\phi ,\psi \) be \(\mcal
{L}\)-formulas and let \(\Sigma \) be a set of \(\mcal {L}\)-formulas. Then
</p>

<p>
\[\Sigma \proves (\phi \rightarrow \psi ) \text { if and only if }\Sigma \cup \{\phi \}\proves \psi .\]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-254"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Exercise: Check that the proof for propositional logic works for predicate logic (with cosmetic changes). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The next theorem is usually included as an extra deduction rule but since we have done that, we need to prove it.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-255"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.53</span></span><span class="amsthmnoteplain"> (Generalisation Theorem)</span>. </span> Let \(\Sigma \) be a set of
\(\mcal {L}\)-formulas and let \(\phi \) be an \(\mcal {L}\)-formula. If \(x\in \Vbl \) does not occur as a free instance in any formula in \(\Sigma \) then
</p>

<p>
\[\Sigma \proves \phi \text { if and only if } \Sigma \proves \forall x \, \phi .\]
</p>

<p>
<b>Note:</b> There may well be a free instance of \(x\) occurring in \(\phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-256"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The reverse direction holds even without the assumption that \(x\) does not occur freely in any formula from \(\Sigma \) by <b>(AxSub)</b> applied with
\(x=t\) and Modus Ponens for proofs.
</p>

<p>
The more difficult and important direction is the forwards direction, i.e., \(\Sigma \proves \phi \) implies \(\Sigma \proves \forall x \, \phi \).
</p>

<p>
Suppose that the variable \(x\) does not occur as a free instance in any formula in \(\Sigma \) and that \((\phi _1,\ldots , \phi _n)\) is a deduction. We will prove that \(\Sigma \proves \forall x \, \phi \) by induction on the length of
the deduction.
</p>

<p>
If \(\phi \) is a logical axiom then, by <b>(Ax\(\forall \))</b>, \(\forall x\phi \) is a logical axiom and thus \(\Sigma \vdash \forall x\phi \). If \(\phi \in \Sigma \), then by assumption, \(x\) does not occur freely in \(\phi \).
Hence, by <b>(AxGen)</b>, \(\phi \rightarrow \forall x\phi \) is a logical axiom. Applying Modus Ponens for proofs we get \(\Sigma \vdash \forall x\phi \).
</p>

<p>
For the induction step, suppose \((\phi _1,...,\phi _{n+1})\) is a proof from \(\Sigma \) with \(\phi =\phi _{n+1}\). From what we have seen above we may assume that \(\phi \) is neither a logical axiom nor an element of \(\Sigma \).
Hence there are \(i,j\leq n\) such that \(\phi _j\) is \(\phi _i\rightarrow \phi _{n+1}\).
</p>

<p>
By (Ax\(\forall \!\rightarrow \)) we have that
</p>

<p>
\[\forall x(\phi _i\rightarrow \phi _{n+1})\ \rightarrow \ (\forall x \phi _i\ \rightarrow \ \forall x\phi _{n+1})\]
</p>

<p>
is a logical axiom. By the induction hypothesis we know \(\Sigma \vdash \forall x\phi _j\), in other words \(\Sigma \vdash \forall x(\phi _i\rightarrow \phi _{n+1})\). So by Modus Ponens for proofs we get \(\Sigma \vdash \forall
x \phi _i\ \rightarrow \ \forall x\phi _{n+1}\). Since also \(\Sigma \vdash \forall x \phi _i\) by induction we may apply Modus Ponens for proofs again to obtain \(\Sigma \vdash \forall x\phi _{n+1}\). <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
