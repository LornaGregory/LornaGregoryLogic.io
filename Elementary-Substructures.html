
<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Elementary Substructures</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-353"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Elementary Substructures ......
-->
<h5 id="autosec-354"><span class="sectionnumber">7.2&#x2003;</span>Elementary Substructures</h5>
<a id="Logic-autopage-354"></a>
<a id="Logic-autofile-15"></a>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-355"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">7.6</span></span>. </span> A map \(f:\mcal {A}\rightarrow \mcal {B}\) is an <b>elementary embedding</b> if for all
\(\mcal {L}\)-formulas \(\phi (x_1,\ldots ,x_n)\) and \(a_1,\ldots ,a_n\in A\), \(\mcal {A}\models \phi [a_1,\ldots ,a_n]\) if and only if \(\mcal {B}\models \phi [f(a_1),\ldots ,f(a_n)]\).
</p>

<p>
If \(A\subseteq B\) and the inclusion map is an elementary embedding then we call \(\mcal {A}\) an <b>elementary substructure</b> of \(\mcal {B}\) and \(\mcal {B}\) an <b>elementary extension</b> of \(\mcal {A}\). We write
\(\mcal {A}\preceq \mcal {B}\) to mean \(\mcal {A}\) is an elementary substructure of \(\mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-356"></a>
<span class="amsthmnameplain">Remark</span><span class="amsthmnumberplain"> <span class="textup">7.7</span></span>. </span> If \(\mcal {A}\) is an elementary substructure of \(\mcal {B}\) then \(\mcal {A}\equiv \mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-357"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">7.8</span></span>. </span> Isomorphisms are elementary embeddings. In particular, isomorphic structures are elementary
equivalent.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-358"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This is proved by induction on the complexity of formulas. Note this was previously stated for automorphisms. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-359"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">7.9</span></span>. </span> If \(\mcal {A}\) is an elementary substructure of \(\mcal {B}\) then \(\mcal {A}\) is a substructure of
\(\mcal {B}\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-360"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This is exercise \(5\) of sheet 10. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-361"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7.10</span></span><span class="amsthmnoteplain"> (Tarski-Vaught Test)</span>. </span> Let \(\mcal {M}\) be an \(\mcal
{L}\)-structure with domain \(M\) and let \(A\subseteq M\). The following are equivalent:
</p>
<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">(i)</span> \(A\) is the domain of an elementary substructure of \(\mcal {M}\). In this situation we will often say \(A\) is an elementary substructure of \(\mcal {M}\).
</p>


</li>
<li>


<p>
<span class="listmarker">(ii)</span> For every \(\mcal {L}\)-formula \(\phi (x,y_1,\ldots ,y_n)\) and \(a_1,\ldots ,a_n\in A\), if \(\mcal {M}\models (\exists x \phi )[a_1,\ldots ,a_n]\) then there is some \(b\in A\) such that
\(\mcal {M}\models \phi [b,a_1,\ldots ,a_n]\).
</p>
</li>
</ul>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-362"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (i)\(\Rightarrow \)(ii) Suppose that \(a_1,\ldots ,a_n\in A\) and \(\mcal {M}\models (\exists x\phi )[a_1,\ldots ,a_n]\). Then by (i), \(\mcal
{A}\models (\exists x\phi )[a_1,\ldots ,a_n]\). By Tarski’s Truth Definition, this implies there exists \(b\in A\) such that \(\mcal {A}\models \phi [b,a_1,\ldots ,a_n]\) as required.
</p>

<p>
(ii)\(\Rightarrow \)(i) The first thing we need to show is that \(A\) is the domain of a substructure. Let \(c\) be a constant symbol of \(\mcal {L}\) and take \(\phi \) to be the formula \(c=v_1\). Then \(\mcal {M}\models \exists v_1\,
\phi \). So, by (ii), \(\mcal {M}\models \phi [b]\) for some \(b\in \mcal {A}\). Therefore \(c^{\mcal {M}}=b\). So \(c^{\mcal {M}}\in A\). Now suppose that \(F\) is an \(n\)-ary function symbol and \(a_1,\ldots ,a_n\in A\). Let
\(\phi (x,y_1,\ldots ,y_n)\) be the formula, \(F(y_1,\ldots ,y_n)=x\). Then \(\mcal {M}\models (\exists x\phi )[a_1,\ldots ,a_n]\). So, by \((ii)\), \(\mcal {A}\models \phi [b,a_1,\ldots ,a_n]\) for some \(b\in A\). Therefore
\(F^{\mcal {M}}(a_1,\ldots ,a_n)=b\). Thus \(A\) is the domain of a substructure of \(\mcal {M}\).
</p>

<p>
We now need to show that this substructure is elementary. We show, by induction on the complexity of the \(\mcal {L}\)-formula \(\phi (y_1,\ldots ,y_n)\), that for all \(a_1,\ldots , a_n\in A\),
</p>

<p>
\[\mcal {M}\models \phi [a_1,\ldots ,a_n] \text { if and only if }\mcal {A}\models \phi [a_1,\ldots ,a_n].\tag {$\dagger $}\]
</p>

<p>
Suppose \(\phi \) is complexity \(0\). The case where \(\phi \) is \(\bot \) is trivial. Suppose \(\phi \) is of the form \(t_1=t_2\) where \(t_1\) and \(t_2\) are terms. It follows by induction on the complexity of terms, just using the fact that
\(\mcal {A}\) is a substructure of \(\mcal {M}\), that if \(h\) is a valuation with \(h(y_i):=a_i\) and \(h(z)\in A\) for all variables \(z\in \Vbl \) that \(t_1^\mcal {M}[h]=t_2^\mcal {M}[h]\) if and only if \(t_1^\mcal {A}[h]=t_2^\mcal
{A}[h]\). Thus \(\mcal {M}\models t_1=t_2[a_1,\ldots ,a_n]\) if and only if \(\mcal {A}\models t_1=t_2[a_1,\ldots ,a_n]\). The case of atomic formulas of the form \(R(t_1,\ldots ,t_n)\) is similar.
</p>

<p>
We now prove the inductive step. If the equivalence holds for \(\phi _1\) and \(\phi _2\) then it is easy to show that the equivalence \((\dagger )\) holds for \((\phi _1\rightarrow \phi _2)\). This implies that if the equivalence \((\dagger
)\) holds for \(\phi \) then it holds for \(\neg \phi \). It’s easy to check that for any formula \(\phi \), \(\neg \exists x\, \neg \phi \equiv \forall x\, \phi \). Thus in order to show that the equivalence \((\dagger )\) is true of
\(\forall x\,\phi \), we just need to show it is true for \(\neg \exists x\, \neg \phi \equiv \forall x\, \phi \).
</p>

<p>
Suppose that \((\dagger )\) holds for \(\phi (x,y_1,\ldots ,y_n)\). By the discussion above, \((\dagger )\) holds of \(\neg \phi \). Suppose \(\mcal {M}\models (\exists x\neg \phi )[a_1,\ldots ,a_n]\) for some \(a_1,\ldots
,a_n\in A\). Then, by (ii), \(\mcal {M}\models \neg \phi [b,a_1,\ldots ,a_n]\) for some \(b\in A\). Since \((\dagger )\) is true for \(\neg \phi \), \(\mcal {A}\models \neg \phi [b,a_1,\ldots ,a_n]\). Thus, by Tarski’s Truth
Definition, \(\mcal {A}\models (\exists x \neg \phi )[a_1,\ldots ,a_n]\). Thus the forward direction of \((\dagger )\) is true for \(\exists x \neg \phi \). Now suppose that \(\mcal {A}\models \exists x \neg \phi [a_1,\ldots
,a_n]\) for \(a_1,\ldots ,a_n\in A\). By Tarski’s Truth Definition, there exists \(b\in A\) such that \(\mcal {A}\models \neg \phi [b,a_1,\ldots ,a_n]\). So, by \((\dagger )\), \(\mcal {M}\models \neg \phi [b,a_1,\ldots ,a_n]\).
So, applying Tarski’s Truth Definition again, we get that \(\mcal {M}\models (\exists x\neg \phi )[a_1,\ldots ,a_n]\). Therefore, \((\dagger )\) holds of \((\exists x\neg \phi )\). But then, by the discussion above, \((\dagger )\)
holds for \(\neg \exists x \neg \phi \). Hence \((\dagger )\) holds for \(\forall x \,\phi \).
</p>

<p>
Thus, by induction on complexity of formulas, \((\dagger )\) holds for all formulas \(\phi \). This implies (i). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
