
<!DOCTYPE html>
<html lang="en-UK">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Lorna Gregory" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="A description." />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Logic — Completeness</title>
<link rel="stylesheet" type="text/css" href="lwarpLorna.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
     subequations: "0",
     section: "",
     loader: {
          load: ['[tex]/tagformat', '[tex]/textmacros'],
     },
     startup: {
          ready() {
              //       These would be replaced by import commands if you wanted to make
              //       a proper extension.
              const Configuration = MathJax._.input.tex.Configuration.Configuration;
              const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
              const Macro = MathJax._.input.tex.Symbol.Macro;
              const TexError = MathJax._.input.tex.TexError.default;
              const ParseUtil = MathJax._.input.tex.ParseUtil.default;
              const expandable = MathJax._.util.Options.expandable;


              //       Insert the replacement string into the TeX string, and check
              //       that there haven't been too many maxro substitutions (prevents
              //       infinite loops).
              const useArgument = (parser, text) => {
                   parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
                   parser.i = 0;
                   if (++parser.macroCount > parser.configuration.options.maxMacros) {
                        throw new TexError('MaxMacroSub1',
                        'MathJax maximum macro substitution count exceeded; ' +
                        'is there a recursive macro call?');
                   }
              }


              //       Create the command map for:
              //            \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
              new CommandMap('Lwarp-macros', {
                   ifstar: 'IfstarFunction',
                   ifnextchar: 'IfnextcharFunction',
                   ifblank: 'IfblankFunction',
                   ifstrequal: 'IfstrequalFunction',
                   gsubstitute: 'GsubstituteFunction',
                   seteqnumber: 'SeteqnumberFunction'
              }, {
                   //       This function implements an ifstar macro.
                   IfstarFunction(parser, name) {
                        const resultstar = parser.GetArgument(name);
                        const resultnostar = parser.GetArgument(name);
                        const star = parser.GetStar();                        // true if there is a *
                        useArgument(parser, star ? resultstar : resultnostar);
                   },


                   //       This function implements an ifnextchar macro.
                   IfnextcharFunction(parser, name) {
                        let whichchar = parser.GetArgument(name);
                        if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
                            // $ syntax highlighting
                            whichchar = String.fromCodePoint(parseInt(whichchar));
                        }
                        const resultnextchar = parser.GetArgument(name);
                        const resultnotnextchar = parser.GetArgument(name);
                        const gotchar = (parser.GetNext() === whichchar);
                        useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
                   },


                   // This function implements an ifblank macro.
                   IfblankFunction(parser, name) {
                        const blankarg = parser.GetArgument(name);
                        const resultblank = parser.GetArgument(name);
                        const resultnotblank = parser.GetArgument(name);
                        const isblank = (blankarg.trim() == "");
                        useArgument(parser, isblank ? resultblank : resultnotblank);
                   },


                   // This function implements an ifstrequal macro.
                   IfstrequalFunction(parser, name) {
                        const strequalfirst = parser.GetArgument(name);
                        const strequalsecond = parser.GetArgument(name);
                        const resultequal = parser.GetArgument(name);
                        const resultnotequal = parser.GetArgument(name);
                        const isequal = (strequalfirst == strequalsecond);
                        useArgument(parser, isequal ? resultequal : resultnotequal);
                   },


                   // This function implements a gsub macro.
                   GsubstituteFunction(parser, name) {
                        const gsubfirst = parser.GetArgument(name);
                        const gsubsecond = parser.GetArgument(name);
                        const gsubthird = parser.GetArgument(name);
                        let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
                        useArgument(parser, gsubresult);
                   },


                   //       This function modifies the equation numbers.
                   SeteqnumberFunction(parser, name) {
                            //   Get the macro parameters
                            const star = parser.GetStar();                      // true if there is a *
                            const optBrackets = parser.GetBrackets(name);        // contents of optional brackets
                            const newsubequations = parser.GetArgument(name);      // the subequations argument
                            const neweqsection = parser.GetArgument(name);      // the eq section argument
                            const neweqnumber = parser.GetArgument(name);        // the eq number argument
                            MathJax.config.subequations=newsubequations ;       // a string with boolean meaning
                            MathJax.config.section=neweqsection ;               // a string with numeric meaning
                            parser.tags.counter = parser.tags.allCounter = neweqnumber ;
                   }


              });


              //       Create the Lwarp-macros package
              Configuration.create('Lwarp-macros', {
                   handler: {macro: ['Lwarp-macros']}
              });


              MathJax.startup.defaultReady();


              // For forward references:
              MathJax.startup.input[0].preFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            MathJax.config.subequations = math.inputData.recompile.subequations;
                            MathJax.config.section = math.inputData.recompile.section;
                   }
              });
              MathJax.startup.input[0].postFilters.add(({math}) => {
                   if (math.inputData.recompile){
                            math.inputData.recompile.subequations = MathJax.config.subequations;
                            math.inputData.recompile.section = MathJax.config.section;
                   }
              });


                   // For \left, \right with unicode-math:
                   const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
                   const {Symbol} = MathJax._.input.tex.Symbol;
                   const {MapHandler} = MathJax._.input.tex.MapHandler;
                   const delimiter = MapHandler.getMap('delimiter');
                   delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
                   delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
                   delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
                   delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
                   delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
                   delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
                   delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
                   delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
                   delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
                   delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
                   delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
                   delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
                   delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
                   delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
                   delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
                   delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
                   delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
                   delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
                   delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
                   delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
                   delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
                   delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
                   delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
                   delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
                   delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
                   delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
                   delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
                   delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
                   delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
                   delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
                   delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
                   delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
                   delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
                   delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
                   delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
                   delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
                   delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
                   delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
                   delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
          }       // ready
     },           // startup


     tex: {
          packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
          tags: "ams",
                   tagformat: {
                            number: function (n) {
                                 if(MathJax.config.subequations==0)
                                        return(MathJax.config.section + n);
                                 else
                                        return(MathJax.config.section + String.fromCharCode(96+n));
                            },
                   },
     }
}
</script>


<script
          id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="Logic-autopage-257"></a>
<nav class="topnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Mathematical Logic</span>
</p>

<p>
Contents
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="Logic.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Introduction.html#autosec-5" class="tocsection" >
<span class="sectionnumber">1</span>&#x2003;Introduction</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-16" class="tocsection" >
<span class="sectionnumber">2</span>&#x2003;Propositional Logic</a>
</p>


<p>
<a href="Propositional-Logic.html#autosec-17" class="tocsubsection" >
<span class="sectionnumber">2.1</span>&#x2003;Propositional formulas</a>
</p>


<p>
<a href="Truth.html#autosec-95" class="tocsubsection" >
<span class="sectionnumber">2.2</span>&#x2003;Truth</a>
</p>


<p>
<a href="Proofs.html#autosec-146" class="tocsubsection" >
<span class="sectionnumber">2.3</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness.html#autosec-157" class="tocsubsection" >
<span class="sectionnumber">2.4</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-168" class="tocsection" >
<span class="sectionnumber">3</span>&#x2003;Predicate Logic</a>
</p>


<p>
<a href="Predicate-Logic.html#autosec-169" class="tocsubsection" >
<span class="sectionnumber">3.1</span>&#x2003;Languages and Structures</a>
</p>


<p>
<a href="Formulas.html#autosec-174" class="tocsubsection" >
<span class="sectionnumber">3.2</span>&#x2003;Formulas</a>
</p>


<p>
<a href="Tarski-Truth-Definition.html#autosec-199" class="tocsubsection" >
<span class="sectionnumber">3.3</span>&#x2003;Tarski’s Truth Definition</a>
</p>


<p>
<a href="Proofs-9.html#autosec-245" class="tocsubsection" >
<span class="sectionnumber">3.4</span>&#x2003;Proofs</a>
</p>


<p>
<a href="Completeness-10.html#autosec-258" class="tocsubsection" >
<span class="sectionnumber">3.5</span>&#x2003;Completeness</a>
</p>


<p>
<a href="Proof-Completeness-Theorem-Predicate-Logic-4th-year-material.html#autosec-272" class="tocsection" >
<span class="sectionnumber">4</span>&#x2003;Proof of the Completeness Theorem for Predicate Logic (4th year material)</a>
</p>


<p>
<a href="Application-Compactness-Theorem-Extension-Constants.html#autosec-310" class="tocsection" >
<span class="sectionnumber">5</span>&#x2003;Application of the Compactness Theorem and Extension by Constants</a>
</p>


<p>
<a href="Universal-Algebra-Substructures-Homomorphisms.html#autosec-336" class="tocsection" >
<span class="sectionnumber">6</span>&#x2003;Universal Algebra: Substructures and Homomorphisms</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-346" class="tocsection" >
<span class="sectionnumber">7</span>&#x2003;Further Model Theory (4th year material)</a>
</p>


<p>
<a href="Further-Model-Theory-4th-year-material.html#autosec-347" class="tocsubsection" >
<span class="sectionnumber">7.1</span>&#x2003;Definable Sets</a>
</p>


<p>
<a href="Elementary-Substructures.html#autosec-354" class="tocsubsection" >
<span class="sectionnumber">7.2</span>&#x2003;Elementary Substructures</a>
</p>


<p>
<a href="Downwards-Lowenheim-Skolem-Theorem.html#autosec-364" class="tocsubsection" >
<span class="sectionnumber">7.3</span>&#x2003;Downwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Upwards-Lowenheim-Skolem-Theorem.html#autosec-368" class="tocsubsection" >
<span class="sectionnumber">7.4</span>&#x2003;Upwards Lo&#x0308;wenheim-Skolem Theorem</a>
</p>


<p>
<a href="Categoricity.html#autosec-371" class="tocsubsection" >
<span class="sectionnumber">7.5</span>&#x2003;Categoricity</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Mathematical Logic</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\TextOrMath }[2]{#2}\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

\(\newcommand {\bm }[1]{\boldsymbol {#1}}\)

\(\newcommand {\R }{\mathbb {R}}\)

\(\newcommand {\C }{\mathbb {C}}\)

\(\newcommand {\Z }{\mathbb {Z}}\)

\(\newcommand {\N }{\mathbb {N}}\)

\(\newcommand {\Q }{\mathbb {Q}}\)

\(\newcommand {\st }{\ \vert \ }\)

\(\newcommand {\mcal }[1]{\mathcal {#1}}\)

\(\newcommand {\TmAlg }{\mathrm {TmAlg}}\)

\(\newcommand {\PROP }{\mathrm {PROP}}\)

\(\newcommand {\PF }{\mathrm {S}}\)

\(\newcommand {\proves }{\vdash }\)

\(\newcommand {\tm }{\textrm {tm}}\)

\(\newcommand {\ctm }{\textrm {ctm}}\)

\(\newcommand {\Fml }{\textrm {Fml}}\)

\(\newcommand {\Fr }{\textrm {Fr}}\)

\(\newcommand {\Vbl }{\textrm {Vbl}}\)

\(\newcommand {\cmpx }{\texttt {cmpx}}\)

\(\newcommand {\supp }{\text {supp}}\)

\(\newcommand {\conn }{\,\square \,}\)

\(\newcommand {\con }{\,\diamond \,}\)

\(\newcommand {\ct }{\texttt {c}}\)

\(\newcommand {\T }{\mathbb {T}}\)

\(\newcommand {\F }{\mathbb {F}}\)

\(\newcommand {\mathlarger }[1]{#1}\)

\(\newcommand {\mathsmaller }[1]{#1}\)

\(\newcommand {\LWRmarginnote }[1][]{}\)

\(\newcommand {\marginnote }[2][]{\qquad {\small \textrm {#2}}\LWRmarginnote }\)

</div>

<!--
...... subsection Completeness ......
-->
<h5 id="autosec-258"><span class="sectionnumber">3.5&#x2003;</span>Completeness</h5>
<a id="Logic-autopage-258"></a>
<a id="Logic-autofile-10"></a>

<p>
Using propositional logic as a guide, we first prove the soundness theorem for predicate logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-259"></a>
<span class="amsthmnameplain">Proposition</span><span class="amsthmnumberplain"> <span class="textup">3.54</span></span><span class="amsthmnoteplain"> (Soundness Theorem)</span>. </span> Let \(\mcal {L}\) be a (first order)
language, \(\Sigma \subseteq \Fml (\mcal {L})\) and \(\phi \in \Fml (\mcal {L})\). If \(\Sigma \proves \phi \) then \(\Sigma \models \phi \).
</p>

</li>

</ul>

</div>

<p>
The proof goes as in propositional logic (because our only deduction rule is modus ponens). We need to input the fact that for all logical axioms \(\phi \), we have \(\models \phi \). This is more work than in propositional logic because our axioms are more
complicated and more numerous.
</p>

<p>
We have already done some work towards the proof of the next lemma and some of the remaining parts will be on your exercise sheet.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-260"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">3.55</span></span>. </span> <a id="SoundAxPred"></a> Let \(\mcal {L}\) be a (first order) language. For all logical axioms \(\phi
\) (of \(\mcal {L}\)), \(\models \phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-261"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> If \(\phi \) is an instance of one of the axioms <b>(AxProp)</b> then \(\models \phi \) by <a
href="Tarski-Truth-Definition.html#proptautaretrue">3.22</a>. If \(\phi \) is an instance of <b>(AxGen)</b> then \(\models \phi \) by <a href="Tarski-Truth-Definition.html#Axgentrueplus">3.36</a>. If \(\phi \) is an instance of
<b>(AxSub)</b> then \(\models \phi \) by <a href="Tarski-Truth-Definition.html#soundnesssubax">3.43</a>. The work towards proving \(\models \phi \) where \(\phi \) is an instance of <b>(AxEq)</b> is started on Exercise Sheet
\(7\) in Exercises \(3\) and \(4\). There will be more on Exercise Sheet \(8\) (I will include the full details after Exercise Sheet \(8\) has been released). The proof that \(\models \phi \) when \(\phi \) is an instance of <b>(Ax\(\forall
\rightarrow \))</b> will be on Exercise Sheet \(8\) - this is a relatively straightforward exercise.
</p>

<p>
It remains to show that \(\models \phi \) when \(\phi \) is an instance of <b>(Ax\(\forall \))</b>. If \(\phi \) is an instance of <b>(Ax\(\forall \))</b> then it is of the form \(\forall x_1\ldots \forall x_n \,\psi \) where \(\psi
\) is an instance of one of the other logical axioms. We have shown (or at least, in some cases, you will show on your exercise sheets) that for all \(\mcal {L}\)-structures \(\mcal {M}\) with domain \(M\) and assignments \(h:\Vbl \rightarrow
M\), \(\mcal {M}\models \psi [h]\). For any variable \(x\), Tarski’s Truth Definition says that \(\mcal {M}\models (\forall x \psi )\) if and only if for all \(a\in M\), \(\mcal {M}\models \psi [h({x\atop a})]\). Since \(h({x\atop a})\)
is also an assignment, this is true. To prove \(\mcal {M}\models \phi [h]\) we just iterate this proof. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
We now prove the Soundness Theorem.
</p>
<div class="amsthmproof">

<a id="Logic-autopage-262"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of the Soundness Theorem.</span></span> The proof is exactly as for the Soundness Theorem for Propositional Logic (<a href="Completeness.html#Soundnessprop">2.48</a>)
except we replace <a href="Truth.html#axiomsaretaut">2.21</a> with <a href="Completeness-10.html#SoundAxPred">3.55</a> and <a href="Truth.html#modimp">2.26</a> with <a
href="Tarski-Truth-Definition.html#MPfortruth">3.34</a>. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
<span role="note" class="marginpar">End of L27 &amp; L28</span>
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-263"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.56</span></span>. </span> We say that a set of \(\mcal {L}\)-sentences \(\Sigma \) is <b>consistent</b> if \(\Sigma \nvdash
\bot \) and <b>inconsistent</b> if \(\Sigma \vdash \bot \).
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-264"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3.57</span></span>. </span> We say that a set of \(\mcal {L}\)-sentences \(\Sigma \) is <b>satisfiable</b> if \(\Sigma \nvDash
\bot \) and <b>unsatisfiable</b> if \(\Sigma \vDash \bot \).
</p>

</li>

</ul>

</div>

<p>
The Soundness Theorem has a useful corollary. We will essentially never prove that a set of \(\mcal {L}\)-sentences is consistent syntactically. Instead, we will always use the Soundness Theorem.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-265"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.58</span></span>. </span> If \(\Sigma \) a set of \(\mcal {L}\)-sentences is satisfiable, that is, has a model, then \(\Sigma \) is
consistent.
</p>

</li>

</ul>

</div>

<p>
The following theorem is called Go&#x0308;del’s Completeness Theorem. I will also refer to it as the Completeness Theorem for Predicate Logic.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-266"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.59</span></span>. </span> Let \(\mcal {L}\) be a (first order) language. Let \(\Sigma \) be a set of \(\mcal {L}\)-formulas and
let \(\phi \) be an \(\mcal {L}\)-formula. Then \(\Sigma \models \phi \) if and only if \(\Sigma \proves \phi \).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-267"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The proof of this theorem is only examinable for 4th years. The proof is in section \(4\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-268"></a>
<span class="amsthmnameplain">Corollary</span><span class="amsthmnumberplain"> <span class="textup">3.60</span></span>. </span> If \(\Sigma \) a set of \(\mcal {L}\)-sentences is consistent then \(\Sigma \) is satisfiable.
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"><a id="Logic-autopage-269"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3.61</span></span><span class="amsthmnoteplain"> (The Compactness Theorem)</span>. </span> Let \(\mcal {L}\) be a (first
order) language and let \(\Sigma \) be a set of \(\mcal {L}\)-sentences. If every finite subset of \(\Sigma \) is satisfiable then \(\Sigma \) is satisfiable.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="Logic-autopage-270"></a>

<ul class="list" style="list-style-type:none">



<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> We prove the contrapositive of the theorem. That is, we show that if a set of \(\mcal {L}\)-sentences \(\Sigma \) does not have a model then there is some
finite subset \(\Sigma _0\) of \(\Sigma \) which does not have a model. The Completeness Theorem states that if \(\Delta \) is a set of \(\mcal {L}\)-formulas and \(\phi \) is an \(\mcal {L}\)-formula then \(\Delta \vdash \phi \) if and
only if \(\Delta \vDash \phi \). Suppose \(\Sigma \) does not have a model. Then \(\Sigma \vDash \bot \). Therefore \(\Sigma \vdash \bot \). Since “Proofs are finite”, there is a subset \(\Sigma _0\) of \(\Sigma \) such that \(\Sigma
_0\vdash \bot \). By the Completeness Theorem, \(\Sigma _0\models \bot \). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
The next \(3\)rd year section is <a href="Application-Compactness-Theorem-Extension-Constants.html#appcomp">5</a>.
</p>

</section>

</main>

</div>


<nav class="botnavigation"><a href="Logic.html" class="linkhome" >
Home</a></nav>

</body>
</html>
